// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace V4l2.AutoGen
{
    public enum V4l2Field : uint
    {
        V4L2FIELD_ANY = 0,
        V4L2FIELD_NONE = 1,
        V4L2FIELD_TOP = 2,
        V4L2FIELD_BOTTOM = 3,
        V4L2FIELD_INTERLACED = 4,
        V4L2FIELD_SEQ_TB = 5,
        V4L2FIELD_SEQ_BT = 6,
        V4L2FIELD_ALTERNATE = 7,
        V4L2FIELD_INTERLACED_TB = 8,
        V4L2FIELD_INTERLACED_BT = 9
    }

    public enum V4l2BufType : uint
    {
        V4L2BUF_TYPE_VIDEO_CAPTURE = 1,
        V4L2BUF_TYPE_VIDEO_OUTPUT = 2,
        V4L2BUF_TYPE_VIDEO_OVERLAY = 3,
        V4L2BUF_TYPE_VBI_CAPTURE = 4,
        V4L2BUF_TYPE_VBI_OUTPUT = 5,
        V4L2BUF_TYPE_SLICED_VBI_CAPTURE = 6,
        V4L2BUF_TYPE_SLICED_VBI_OUTPUT = 7,
        V4L2BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
        V4L2BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
        V4L2BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10,
        V4L2BUF_TYPE_SDR_CAPTURE = 11,
        V4L2BUF_TYPE_SDR_OUTPUT = 12,
        V4L2BUF_TYPE_META_CAPTURE = 13,
        V4L2BUF_TYPE_META_OUTPUT = 14,
        V4L2BUF_TYPE_PRIVATE = 0x80
    }

    public enum V4l2TunerType : uint
    {
        V4L2TUNER_RADIO = 1,
        V4L2TUNER_ANALOG_TV = 2,
        V4L2TUNER_DIGITAL_TV = 3,
        V4L2TUNER_SDR = 4,
        V4L2TUNER_RF = 5
    }

    public enum V4l2Memory : uint
    {
        V4L2MEMORY_MMAP = 1,
        V4L2MEMORY_USERPTR = 2,
        V4L2MEMORY_OVERLAY = 3,
        V4L2MEMORY_DMABUF = 4
    }

    public enum V4l2Colorspace : uint
    {
        V4L2COLORSPACE_DEFAULT = 0,
        V4L2COLORSPACE_SMPTE170M = 1,
        V4L2COLORSPACE_SMPTE240M = 2,
        V4L2COLORSPACE_REC709 = 3,
        V4L2COLORSPACE_BT878 = 4,
        V4L2COLORSPACE_470SYSTEM_M = 5,
        V4L2COLORSPACE_470SYSTEM_BG = 6,
        V4L2COLORSPACE_JPEG = 7,
        V4L2COLORSPACE_SRGB = 8,
        V4L2COLORSPACE_OPRGB = 9,
        V4L2COLORSPACE_BT2020 = 10,
        V4L2COLORSPACE_RAW = 11,
        V4L2COLORSPACE_DCI_P3 = 12
    }

    public enum V4l2XferFunc : uint
    {
        V4L2XFER_FUNC_DEFAULT = 0,
        V4L2XFER_FUNC_709 = 1,
        V4L2XFER_FUNC_SRGB = 2,
        V4L2XFER_FUNC_OPRGB = 3,
        V4L2XFER_FUNC_SMPTE240M = 4,
        V4L2XFER_FUNC_NONE = 5,
        V4L2XFER_FUNC_DCI_P3 = 6,
        V4L2XFER_FUNC_SMPTE2084 = 7
    }

    public enum V4l2YcbcrEncoding : uint
    {
        V4L2YCBCR_ENC_DEFAULT = 0,
        V4L2YCBCR_ENC_601 = 1,
        V4L2YCBCR_ENC_709 = 2,
        V4L2YCBCR_ENC_XV601 = 3,
        V4L2YCBCR_ENC_XV709 = 4,
        V4L2YCBCR_ENC_SYCC = 5,
        V4L2YCBCR_ENC_BT2020 = 6,
        V4L2YCBCR_ENC_BT2020CONST_LUM = 7,
        V4L2YCBCR_ENC_SMPTE240M = 8
    }

    public enum V4l2HsvEncoding : uint
    {
        V4L2HSV_ENC_180 = 128,
        V4L2HSV_ENC_256 = 129
    }

    public enum V4l2Quantization : uint
    {
        V4L2QUANTIZATION_DEFAULT = 0,
        V4L2QUANTIZATION_FULL_RANGE = 1,
        V4L2QUANTIZATION_LIM_RANGE = 2
    }

    public enum V4l2Priority : uint
    {
        V4L2PRIORITY_UNSET = 0,
        V4L2PRIORITY_BACKGROUND = 1,
        V4L2PRIORITY_INTERACTIVE = 2,
        V4L2PRIORITY_RECORD = 3,
        V4L2PRIORITY_DEFAULT = 2
    }

    public enum V4l2Frmsizetypes : uint
    {
        V4L2FRMSIZE_TYPE_DISCRETE = 1,
        V4L2FRMSIZE_TYPE_CONTINUOUS = 2,
        V4L2FRMSIZE_TYPE_STEPWISE = 3
    }

    public enum V4l2Frmivaltypes : uint
    {
        V4L2FRMIVAL_TYPE_DISCRETE = 1,
        V4L2FRMIVAL_TYPE_CONTINUOUS = 2,
        V4L2FRMIVAL_TYPE_STEPWISE = 3
    }

    public enum V4l2CtrlType : uint
    {
        V4L2CTRL_TYPE_INTEGER = 1,
        V4L2CTRL_TYPE_BOOLEAN = 2,
        V4L2CTRL_TYPE_MENU = 3,
        V4L2CTRL_TYPE_BUTTON = 4,
        V4L2CTRL_TYPE_INTEGER64 = 5,
        V4L2CTRL_TYPE_CTRL_CLASS = 6,
        V4L2CTRL_TYPE_STRING = 7,
        V4L2CTRL_TYPE_BITMASK = 8,
        V4L2CTRL_TYPE_INTEGER_MENU = 9,
        V4L2CTRL_COMPOUND_TYPES = 0x100,
        V4L2CTRL_TYPE_U8 = 0x100,
        V4L2CTRL_TYPE_U16 = 0x101,
        V4L2CTRL_TYPE_U32 = 0x102,
        V4L2CTRL_TYPE_AREA = 0x106,
        V4L2CTRL_TYPE_HDR10CLL_INFO = 0x110,
        V4L2CTRL_TYPE_HDR10MASTERING_DISPLAY = 0x111,
        V4L2CTRL_TYPE_H264SPS = 0x200,
        V4L2CTRL_TYPE_H264PPS = 0x201,
        V4L2CTRL_TYPE_H264SCALING_MATRIX = 0x202,
        V4L2CTRL_TYPE_H264SLICE_PARAMS = 0x203,
        V4L2CTRL_TYPE_H264DECODE_PARAMS = 0x204,
        V4L2CTRL_TYPE_H264PRED_WEIGHTS = 0x205,
        V4L2CTRL_TYPE_FWHT_PARAMS = 0x220,
        V4L2CTRL_TYPE_VP8FRAME = 0x240,
        V4L2CTRL_TYPE_MPEG2QUANTISATION = 0x250,
        V4L2CTRL_TYPE_MPEG2SEQUENCE = 0x251,
        V4L2CTRL_TYPE_MPEG2PICTURE = 0x252
    }

    public unsafe partial class V4l2Rect : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal int left;
            internal int top;
            internal uint width;
            internal uint height;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN9v4l2_rectC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Rect> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Rect>();

        protected bool __ownsNativeInstance;

        internal static V4l2Rect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Rect(native.ToPointer(), skipVTables);
        }

        internal static V4l2Rect __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Rect)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Rect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Rect(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Rect(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Rect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Rect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Rect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Rect(global::V4l2.AutoGen.V4l2Rect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Rect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Rect.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Rect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Left
        {
            get
            {
                return ((__Internal*)__Instance)->left;
            }

            set
            {
                ((__Internal*)__Instance)->left = value;
            }
        }

        public int Top
        {
            get
            {
                return ((__Internal*)__Instance)->top;
            }

            set
            {
                ((__Internal*)__Instance)->top = value;
            }
        }

        public uint Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public uint Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }
    }

    public unsafe partial class V4l2Fract : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal uint numerator;
            internal uint denominator;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN10v4l2_fractC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Fract> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Fract>();

        protected bool __ownsNativeInstance;

        internal static V4l2Fract __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Fract(native.ToPointer(), skipVTables);
        }

        internal static V4l2Fract __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Fract)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Fract __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Fract(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Fract(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Fract(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Fract()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Fract.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Fract(global::V4l2.AutoGen.V4l2Fract _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Fract.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Fract.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Fract.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Numerator
        {
            get
            {
                return ((__Internal*)__Instance)->numerator;
            }

            set
            {
                ((__Internal*)__Instance)->numerator = value;
            }
        }

        public uint Denominator
        {
            get
            {
                return ((__Internal*)__Instance)->denominator;
            }

            set
            {
                ((__Internal*)__Instance)->denominator = value;
            }
        }
    }

    public unsafe partial class V4l2Area : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal uint width;
            internal uint height;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN9v4l2_areaC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Area> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Area>();

        protected bool __ownsNativeInstance;

        internal static V4l2Area __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Area(native.ToPointer(), skipVTables);
        }

        internal static V4l2Area __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Area)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Area __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Area(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Area(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Area(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Area()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Area.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Area(global::V4l2.AutoGen.V4l2Area _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Area.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Area.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Area.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public uint Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }
    }

    /// <summary>struct v4l2_capability - Describes V4L2 device caps returned by VIDIOC_QUERYCAP</summary>
    /// <remarks>
    /// <para>name of the driver module (e.g. &quot;bttv&quot;)</para>
    /// <para>name of the card (e.g. &quot;Hauppauge WinTV&quot;)</para>
    /// <para>_info:	   name of the bus (e.g. &quot;PCI:&quot; + pci_name(pci_dev) )</para>
    /// <para>:	   KERNEL_VERSION</para>
    /// <para>: capabilities of the physical device as a whole</para>
    /// <para>_caps:  capabilities accessed via this particular device (node)</para>
    /// <para>:	   reserved fields for future extensions</para>
    /// </remarks>
    public unsafe partial class V4l2Capability : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 104)]
        public partial struct __Internal
        {
            internal fixed byte driver[16];
            internal fixed byte card[32];
            internal fixed byte bus_info[32];
            internal uint version;
            internal uint capabilities;
            internal uint device_caps;
            internal fixed uint reserved[3];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN15v4l2_capabilityC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Capability> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Capability>();

        protected bool __ownsNativeInstance;

        internal static V4l2Capability __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Capability(native.ToPointer(), skipVTables);
        }

        internal static V4l2Capability __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Capability)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Capability __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Capability(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Capability(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Capability(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Capability()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Capability.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Capability(global::V4l2.AutoGen.V4l2Capability _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Capability.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Capability.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Capability.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte[] Driver
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->driver, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->driver[i] = value[i];
                }
            }
        }

        public byte[] Card
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->card, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->card[i] = value[i];
                }
            }
        }

        public byte[] BusInfo
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->bus_info, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->bus_info[i] = value[i];
                }
            }
        }

        public uint Version
        {
            get
            {
                return ((__Internal*)__Instance)->version;
            }

            set
            {
                ((__Internal*)__Instance)->version = value;
            }
        }

        public uint Capabilities
        {
            get
            {
                return ((__Internal*)__Instance)->capabilities;
            }

            set
            {
                ((__Internal*)__Instance)->capabilities = value;
            }
        }

        public uint DeviceCaps
        {
            get
            {
                return ((__Internal*)__Instance)->device_caps;
            }

            set
            {
                ((__Internal*)__Instance)->device_caps = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2PixFormat : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint width;

            [FieldOffset(4)]
            internal uint height;

            [FieldOffset(8)]
            internal uint pixelformat;

            [FieldOffset(12)]
            internal uint field;

            [FieldOffset(16)]
            internal uint bytesperline;

            [FieldOffset(20)]
            internal uint sizeimage;

            [FieldOffset(24)]
            internal uint colorspace;

            [FieldOffset(28)]
            internal uint priv;

            [FieldOffset(32)]
            internal uint flags;

            [FieldOffset(36)]
            internal uint ycbcr_enc;

            [FieldOffset(36)]
            internal uint hsv_enc;

            [FieldOffset(40)]
            internal uint quantization;

            [FieldOffset(44)]
            internal uint xfer_func;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN15v4l2_pix_formatC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2PixFormat> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2PixFormat>();

        protected bool __ownsNativeInstance;

        internal static V4l2PixFormat __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2PixFormat(native.ToPointer(), skipVTables);
        }

        internal static V4l2PixFormat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2PixFormat)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2PixFormat __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2PixFormat(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2PixFormat(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2PixFormat(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2PixFormat()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2PixFormat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2PixFormat(global::V4l2.AutoGen.V4l2PixFormat _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2PixFormat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2PixFormat.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2PixFormat.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public uint Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        public uint Pixelformat
        {
            get
            {
                return ((__Internal*)__Instance)->pixelformat;
            }

            set
            {
                ((__Internal*)__Instance)->pixelformat = value;
            }
        }

        public uint Field
        {
            get
            {
                return ((__Internal*)__Instance)->field;
            }

            set
            {
                ((__Internal*)__Instance)->field = value;
            }
        }

        public uint Bytesperline
        {
            get
            {
                return ((__Internal*)__Instance)->bytesperline;
            }

            set
            {
                ((__Internal*)__Instance)->bytesperline = value;
            }
        }

        public uint Sizeimage
        {
            get
            {
                return ((__Internal*)__Instance)->sizeimage;
            }

            set
            {
                ((__Internal*)__Instance)->sizeimage = value;
            }
        }

        public uint Colorspace
        {
            get
            {
                return ((__Internal*)__Instance)->colorspace;
            }

            set
            {
                ((__Internal*)__Instance)->colorspace = value;
            }
        }

        public uint Priv
        {
            get
            {
                return ((__Internal*)__Instance)->priv;
            }

            set
            {
                ((__Internal*)__Instance)->priv = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public uint YcbcrEnc
        {
            get
            {
                return ((__Internal*)__Instance)->ycbcr_enc;
            }

            set
            {
                ((__Internal*)__Instance)->ycbcr_enc = value;
            }
        }

        public uint HsvEnc
        {
            get
            {
                return ((__Internal*)__Instance)->hsv_enc;
            }

            set
            {
                ((__Internal*)__Instance)->hsv_enc = value;
            }
        }

        public uint Quantization
        {
            get
            {
                return ((__Internal*)__Instance)->quantization;
            }

            set
            {
                ((__Internal*)__Instance)->quantization = value;
            }
        }

        public uint XferFunc
        {
            get
            {
                return ((__Internal*)__Instance)->xfer_func;
            }

            set
            {
                ((__Internal*)__Instance)->xfer_func = value;
            }
        }
    }

    public unsafe partial class V4l2Fmtdesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal uint index;
            internal uint type;
            internal uint flags;
            internal fixed byte description[32];
            internal uint pixelformat;
            internal uint mbus_code;
            internal fixed uint reserved[3];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN12v4l2_fmtdescC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Fmtdesc> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Fmtdesc>();

        protected bool __ownsNativeInstance;

        internal static V4l2Fmtdesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Fmtdesc(native.ToPointer(), skipVTables);
        }

        internal static V4l2Fmtdesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Fmtdesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Fmtdesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Fmtdesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Fmtdesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Fmtdesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Fmtdesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Fmtdesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Fmtdesc(global::V4l2.AutoGen.V4l2Fmtdesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Fmtdesc.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Fmtdesc.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Fmtdesc.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public byte[] Description
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->description, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->description[i] = value[i];
                }
            }
        }

        public uint Pixelformat
        {
            get
            {
                return ((__Internal*)__Instance)->pixelformat;
            }

            set
            {
                ((__Internal*)__Instance)->pixelformat = value;
            }
        }

        public uint MbusCode
        {
            get
            {
                return ((__Internal*)__Instance)->mbus_code;
            }

            set
            {
                ((__Internal*)__Instance)->mbus_code = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2FrmsizeDiscrete : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal uint width;
            internal uint height;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN21v4l2_frmsize_discreteC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2FrmsizeDiscrete> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2FrmsizeDiscrete>();

        protected bool __ownsNativeInstance;

        internal static V4l2FrmsizeDiscrete __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2FrmsizeDiscrete(native.ToPointer(), skipVTables);
        }

        internal static V4l2FrmsizeDiscrete __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2FrmsizeDiscrete)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2FrmsizeDiscrete __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2FrmsizeDiscrete(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2FrmsizeDiscrete(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2FrmsizeDiscrete(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2FrmsizeDiscrete()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2FrmsizeDiscrete.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2FrmsizeDiscrete(global::V4l2.AutoGen.V4l2FrmsizeDiscrete _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2FrmsizeDiscrete.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2FrmsizeDiscrete.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2FrmsizeDiscrete.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public uint Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }
    }

    public unsafe partial class V4l2FrmsizeStepwise : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal uint min_width;
            internal uint max_width;
            internal uint step_width;
            internal uint min_height;
            internal uint max_height;
            internal uint step_height;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN21v4l2_frmsize_stepwiseC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2FrmsizeStepwise> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2FrmsizeStepwise>();

        protected bool __ownsNativeInstance;

        internal static V4l2FrmsizeStepwise __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2FrmsizeStepwise(native.ToPointer(), skipVTables);
        }

        internal static V4l2FrmsizeStepwise __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2FrmsizeStepwise)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2FrmsizeStepwise __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2FrmsizeStepwise(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2FrmsizeStepwise(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2FrmsizeStepwise(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2FrmsizeStepwise()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2FrmsizeStepwise.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2FrmsizeStepwise(global::V4l2.AutoGen.V4l2FrmsizeStepwise _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2FrmsizeStepwise.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2FrmsizeStepwise.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2FrmsizeStepwise.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint MinWidth
        {
            get
            {
                return ((__Internal*)__Instance)->min_width;
            }

            set
            {
                ((__Internal*)__Instance)->min_width = value;
            }
        }

        public uint MaxWidth
        {
            get
            {
                return ((__Internal*)__Instance)->max_width;
            }

            set
            {
                ((__Internal*)__Instance)->max_width = value;
            }
        }

        public uint StepWidth
        {
            get
            {
                return ((__Internal*)__Instance)->step_width;
            }

            set
            {
                ((__Internal*)__Instance)->step_width = value;
            }
        }

        public uint MinHeight
        {
            get
            {
                return ((__Internal*)__Instance)->min_height;
            }

            set
            {
                ((__Internal*)__Instance)->min_height = value;
            }
        }

        public uint MaxHeight
        {
            get
            {
                return ((__Internal*)__Instance)->max_height;
            }

            set
            {
                ((__Internal*)__Instance)->max_height = value;
            }
        }

        public uint StepHeight
        {
            get
            {
                return ((__Internal*)__Instance)->step_height;
            }

            set
            {
                ((__Internal*)__Instance)->step_height = value;
            }
        }
    }

    public unsafe partial class V4l2Frmsizeenum : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 44)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint index;

            [FieldOffset(4)]
            internal uint pixel_format;

            [FieldOffset(8)]
            internal uint type;

            [FieldOffset(12)]
            internal global::V4l2.AutoGen.V4l2FrmsizeDiscrete.__Internal discrete;

            [FieldOffset(12)]
            internal global::V4l2.AutoGen.V4l2FrmsizeStepwise.__Internal stepwise;

            [FieldOffset(36)]
            internal fixed uint reserved[2];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN16v4l2_frmsizeenumC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Frmsizeenum> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Frmsizeenum>();

        protected bool __ownsNativeInstance;

        internal static V4l2Frmsizeenum __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Frmsizeenum(native.ToPointer(), skipVTables);
        }

        internal static V4l2Frmsizeenum __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Frmsizeenum)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Frmsizeenum __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Frmsizeenum(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Frmsizeenum(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Frmsizeenum(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Frmsizeenum()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Frmsizeenum.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Frmsizeenum(global::V4l2.AutoGen.V4l2Frmsizeenum _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Frmsizeenum.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Frmsizeenum.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Frmsizeenum.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public uint PixelFormat
        {
            get
            {
                return ((__Internal*)__Instance)->pixel_format;
            }

            set
            {
                ((__Internal*)__Instance)->pixel_format = value;
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public global::V4l2.AutoGen.V4l2FrmsizeDiscrete Discrete
        {
            get
            {
                return global::V4l2.AutoGen.V4l2FrmsizeDiscrete.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->discrete));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->discrete = *(global::V4l2.AutoGen.V4l2FrmsizeDiscrete.__Internal*) value.__Instance;
            }
        }

        public global::V4l2.AutoGen.V4l2FrmsizeStepwise Stepwise
        {
            get
            {
                return global::V4l2.AutoGen.V4l2FrmsizeStepwise.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->stepwise));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->stepwise = *(global::V4l2.AutoGen.V4l2FrmsizeStepwise.__Internal*) value.__Instance;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2FrmivalStepwise : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal global::V4l2.AutoGen.V4l2Fract.__Internal min;
            internal global::V4l2.AutoGen.V4l2Fract.__Internal max;
            internal global::V4l2.AutoGen.V4l2Fract.__Internal step;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN21v4l2_frmival_stepwiseC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2FrmivalStepwise> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2FrmivalStepwise>();

        protected bool __ownsNativeInstance;

        internal static V4l2FrmivalStepwise __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2FrmivalStepwise(native.ToPointer(), skipVTables);
        }

        internal static V4l2FrmivalStepwise __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2FrmivalStepwise)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2FrmivalStepwise __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2FrmivalStepwise(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2FrmivalStepwise(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2FrmivalStepwise(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2FrmivalStepwise()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2FrmivalStepwise.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2FrmivalStepwise(global::V4l2.AutoGen.V4l2FrmivalStepwise _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2FrmivalStepwise.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2FrmivalStepwise.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2FrmivalStepwise.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::V4l2.AutoGen.V4l2Fract Min
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Fract.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->min));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->min = *(global::V4l2.AutoGen.V4l2Fract.__Internal*) value.__Instance;
            }
        }

        public global::V4l2.AutoGen.V4l2Fract Max
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Fract.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->max));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->max = *(global::V4l2.AutoGen.V4l2Fract.__Internal*) value.__Instance;
            }
        }

        public global::V4l2.AutoGen.V4l2Fract Step
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Fract.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->step));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->step = *(global::V4l2.AutoGen.V4l2Fract.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class V4l2Frmivalenum : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 52)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint index;

            [FieldOffset(4)]
            internal uint pixel_format;

            [FieldOffset(8)]
            internal uint width;

            [FieldOffset(12)]
            internal uint height;

            [FieldOffset(16)]
            internal uint type;

            [FieldOffset(20)]
            internal global::V4l2.AutoGen.V4l2Fract.__Internal discrete;

            [FieldOffset(20)]
            internal global::V4l2.AutoGen.V4l2FrmivalStepwise.__Internal stepwise;

            [FieldOffset(44)]
            internal fixed uint reserved[2];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN16v4l2_frmivalenumC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Frmivalenum> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Frmivalenum>();

        protected bool __ownsNativeInstance;

        internal static V4l2Frmivalenum __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Frmivalenum(native.ToPointer(), skipVTables);
        }

        internal static V4l2Frmivalenum __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Frmivalenum)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Frmivalenum __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Frmivalenum(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Frmivalenum(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Frmivalenum(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Frmivalenum()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Frmivalenum.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Frmivalenum(global::V4l2.AutoGen.V4l2Frmivalenum _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Frmivalenum.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Frmivalenum.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Frmivalenum.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public uint PixelFormat
        {
            get
            {
                return ((__Internal*)__Instance)->pixel_format;
            }

            set
            {
                ((__Internal*)__Instance)->pixel_format = value;
            }
        }

        public uint Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public uint Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public global::V4l2.AutoGen.V4l2Fract Discrete
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Fract.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->discrete));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->discrete = *(global::V4l2.AutoGen.V4l2Fract.__Internal*) value.__Instance;
            }
        }

        public global::V4l2.AutoGen.V4l2FrmivalStepwise Stepwise
        {
            get
            {
                return global::V4l2.AutoGen.V4l2FrmivalStepwise.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->stepwise));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->stepwise = *(global::V4l2.AutoGen.V4l2FrmivalStepwise.__Internal*) value.__Instance;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2Timecode : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal uint type;
            internal uint flags;
            internal byte frames;
            internal byte seconds;
            internal byte minutes;
            internal byte hours;
            internal fixed byte userbits[4];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN13v4l2_timecodeC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Timecode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Timecode>();

        protected bool __ownsNativeInstance;

        internal static V4l2Timecode __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Timecode(native.ToPointer(), skipVTables);
        }

        internal static V4l2Timecode __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Timecode)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Timecode __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Timecode(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Timecode(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Timecode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Timecode()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Timecode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Timecode(global::V4l2.AutoGen.V4l2Timecode _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Timecode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Timecode.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Timecode.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public byte Frames
        {
            get
            {
                return ((__Internal*)__Instance)->frames;
            }

            set
            {
                ((__Internal*)__Instance)->frames = value;
            }
        }

        public byte Seconds
        {
            get
            {
                return ((__Internal*)__Instance)->seconds;
            }

            set
            {
                ((__Internal*)__Instance)->seconds = value;
            }
        }

        public byte Minutes
        {
            get
            {
                return ((__Internal*)__Instance)->minutes;
            }

            set
            {
                ((__Internal*)__Instance)->minutes = value;
            }
        }

        public byte Hours
        {
            get
            {
                return ((__Internal*)__Instance)->hours;
            }

            set
            {
                ((__Internal*)__Instance)->hours = value;
            }
        }

        public byte[] Userbits
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->userbits, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->userbits[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2Jpegcompression : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 140)]
        public partial struct __Internal
        {
            internal int quality;
            internal int APPn;
            internal int APP_len;
            internal fixed sbyte APP_data[60];
            internal int COM_len;
            internal fixed sbyte COM_data[60];
            internal uint jpeg_markers;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN20v4l2_jpegcompressionC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Jpegcompression> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Jpegcompression>();

        protected bool __ownsNativeInstance;

        internal static V4l2Jpegcompression __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Jpegcompression(native.ToPointer(), skipVTables);
        }

        internal static V4l2Jpegcompression __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Jpegcompression)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Jpegcompression __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Jpegcompression(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Jpegcompression(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Jpegcompression(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Jpegcompression()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Jpegcompression.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Jpegcompression(global::V4l2.AutoGen.V4l2Jpegcompression _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Jpegcompression.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Jpegcompression.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Jpegcompression.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Quality
        {
            get
            {
                return ((__Internal*)__Instance)->quality;
            }

            set
            {
                ((__Internal*)__Instance)->quality = value;
            }
        }

        public int APPn
        {
            get
            {
                return ((__Internal*)__Instance)->APPn;
            }

            set
            {
                ((__Internal*)__Instance)->APPn = value;
            }
        }

        public int APP_len
        {
            get
            {
                return ((__Internal*)__Instance)->APP_len;
            }

            set
            {
                ((__Internal*)__Instance)->APP_len = value;
            }
        }

        public sbyte[] APP_data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->APP_data, 60);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 60; i++)
                        ((__Internal*)__Instance)->APP_data[i] = value[i];
                }
            }
        }

        public int COM_len
        {
            get
            {
                return ((__Internal*)__Instance)->COM_len;
            }

            set
            {
                ((__Internal*)__Instance)->COM_len = value;
            }
        }

        public sbyte[] COM_data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->COM_data, 60);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 60; i++)
                        ((__Internal*)__Instance)->COM_data[i] = value[i];
                }
            }
        }

        public uint JpegMarkers
        {
            get
            {
                return ((__Internal*)__Instance)->jpeg_markers;
            }

            set
            {
                ((__Internal*)__Instance)->jpeg_markers = value;
            }
        }
    }

    public unsafe partial class V4l2Requestbuffers : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            internal uint count;
            internal uint type;
            internal uint memory;
            internal uint capabilities;
            internal byte flags;
            internal fixed byte reserved[3];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN19v4l2_requestbuffersC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Requestbuffers> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Requestbuffers>();

        protected bool __ownsNativeInstance;

        internal static V4l2Requestbuffers __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Requestbuffers(native.ToPointer(), skipVTables);
        }

        internal static V4l2Requestbuffers __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Requestbuffers)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Requestbuffers __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Requestbuffers(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Requestbuffers(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Requestbuffers(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Requestbuffers()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Requestbuffers.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Requestbuffers(global::V4l2.AutoGen.V4l2Requestbuffers _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Requestbuffers.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Requestbuffers.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Requestbuffers.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Memory
        {
            get
            {
                return ((__Internal*)__Instance)->memory;
            }

            set
            {
                ((__Internal*)__Instance)->memory = value;
            }
        }

        public uint Capabilities
        {
            get
            {
                return ((__Internal*)__Instance)->capabilities;
            }

            set
            {
                ((__Internal*)__Instance)->capabilities = value;
            }
        }

        public byte Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public byte[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->reserved, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    /// <summary>
    /// <para>struct v4l2_plane - plane info for multi-planar buffers</para>
    /// <para>number of bytes occupied by data in the plane (payload)</para>
    /// <para>size of this plane (NOT the payload) in bytes</para>
    /// <para>when memory in the associated struct v4l2_buffer is</para>
    /// <para>V4L2_MEMORY_MMAP, equals the offset from the start of</para>
    /// <para>the device memory for this plane (or is a &quot;cookie&quot; that</para>
    /// <para>should be passed to mmap() called on the video node)</para>
    /// <para>when memory is V4L2_MEMORY_USERPTR, a userspace pointer</para>
    /// <para>pointing to this plane</para>
    /// <para>when memory is V4L2_MEMORY_DMABUF, a userspace file</para>
    /// <para>descriptor associated with this plane</para>
    /// <para>union ofand</para>
    /// </summary>
    /// <remarks>
    /// <para>_offset:	offset in the plane to the start of data; usually 0,</para>
    /// <para>unless there is a header in front of the data</para>
    /// <para>:		drivers and applications must zero this array</para>
    /// <para>Multi-planar buffers consist of one or more planes, e.g. an YCbCr buffer</para>
    /// <para>with two planes can have one plane for Y, and another for interleaved CbCr</para>
    /// <para>components. Each plane can reside in a separate memory buffer, or even in</para>
    /// <para>a completely separate memory node (e.g. in embedded devices).</para>
    /// </remarks>
    public unsafe partial class V4l2Plane : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal uint bytesused;
            internal uint length;
            internal global::V4l2.AutoGen.V4l2Plane.M.__Internal m;
            internal uint data_offset;
            internal fixed uint reserved[11];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN10v4l2_planeC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial struct M
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint mem_offset;

                [FieldOffset(0)]
                internal ulong userptr;

                [FieldOffset(0)]
                internal int fd;

                [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN10v4l2_planeUt_C2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
            }

            private M.__Internal __instance;
            internal M.__Internal __Instance { get { return __instance; } }

            internal static M __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new M(native.ToPointer(), skipVTables);
            }

            internal static M __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new M(native, skipVTables);
            }

            private M(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private M(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::V4l2.AutoGen.V4l2Plane.M.__Internal*) native;
            }

            public M(global::V4l2.AutoGen.V4l2Plane.M __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            public uint MemOffset
            {
                get
                {
                    return __instance.mem_offset;
                }

                set
                {
                    __instance.mem_offset = value;
                }
            }

            public ulong Userptr
            {
                get
                {
                    return __instance.userptr;
                }

                set
                {
                    __instance.userptr = value;
                }
            }

            public int Fd
            {
                get
                {
                    return __instance.fd;
                }

                set
                {
                    __instance.fd = value;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Plane> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Plane>();

        protected bool __ownsNativeInstance;

        internal static V4l2Plane __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Plane(native.ToPointer(), skipVTables);
        }

        internal static V4l2Plane __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Plane)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Plane __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Plane(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Plane(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Plane(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Plane()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Plane.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Plane(global::V4l2.AutoGen.V4l2Plane _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Plane.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Plane.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Plane.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Bytesused
        {
            get
            {
                return ((__Internal*)__Instance)->bytesused;
            }

            set
            {
                ((__Internal*)__Instance)->bytesused = value;
            }
        }

        public uint Length
        {
            get
            {
                return ((__Internal*)__Instance)->length;
            }

            set
            {
                ((__Internal*)__Instance)->length = value;
            }
        }

        public global::V4l2.AutoGen.V4l2Plane.M m
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Plane.M.__CreateInstance(((__Internal*)__Instance)->m);
            }

            set
            {
                ((__Internal*)__Instance)->m = value.__Instance;
            }
        }

        public uint DataOffset
        {
            get
            {
                return ((__Internal*)__Instance)->data_offset;
            }

            set
            {
                ((__Internal*)__Instance)->data_offset = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 11);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 11; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    /// <summary>
    /// <para>struct v4l2_buffer - video buffer info</para>
    /// <para>id number of the buffer</para>
    /// <para>enum v4l2_buf_type; buffer type (type == *_MPLANE for</para>
    /// <para>multiplanar buffers);</para>
    /// <para>number of bytes occupied by data in the buffer (payload);</para>
    /// <para>unused (set to 0) for multiplanar buffers</para>
    /// <para>buffer informational flags</para>
    /// <para>enum v4l2_field; field order of the image in the buffer</para>
    /// <para>frame timestamp</para>
    /// <para>frame timecode</para>
    /// <para>sequence count of this frame</para>
    /// <para>enum v4l2_memory; the method, in which the actual video data is</para>
    /// <para>passed</para>
    /// <para>for non-multiplanar buffers with memory == V4L2_MEMORY_MMAP;</para>
    /// <para>offset from the start of the device memory for this plane,</para>
    /// <para>(or a &quot;cookie&quot; that should be passed to mmap() as offset)</para>
    /// <para>for non-multiplanar buffers with memory == V4L2_MEMORY_USERPTR;</para>
    /// <para>a userspace pointer pointing to this buffer</para>
    /// <para>for non-multiplanar buffers with memory == V4L2_MEMORY_DMABUF;</para>
    /// <para>a userspace file descriptor associated with this buffer</para>
    /// <para>for multiplanar buffers; userspace pointer to the array of plane</para>
    /// <para>info structs for this buffer</para>
    /// <para>union ofand</para>
    /// <para>size in bytes of the buffer (NOT its payload) for single-plane</para>
    /// <para>buffers (when type != *_MPLANE); number of elements in the</para>
    /// <para>planes array for multi-plane buffers</para>
    /// <para>drivers and applications must zero this field</para>
    /// <para>fd of the request that this buffer should use</para>
    /// <para>for backwards compatibility with applications that do not know</para>
    /// <para>about</para>
    /// </summary>
    /// <remarks>
    /// <para>Contains data exchanged by application and driver using one of the Streaming</para>
    /// <para>I/O methods.</para>
    /// </remarks>
    public unsafe partial class V4l2Buffer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint index;

            [FieldOffset(4)]
            internal uint type;

            [FieldOffset(8)]
            internal uint bytesused;

            [FieldOffset(12)]
            internal uint flags;

            [FieldOffset(16)]
            internal uint field;

            [FieldOffset(24)]
            internal global::Timeval.__Internal timestamp;

            [FieldOffset(40)]
            internal global::V4l2.AutoGen.V4l2Timecode.__Internal timecode;

            [FieldOffset(56)]
            internal uint sequence;

            [FieldOffset(60)]
            internal uint memory;

            [FieldOffset(64)]
            internal global::V4l2.AutoGen.V4l2Buffer.M.__Internal m;

            [FieldOffset(72)]
            internal uint length;

            [FieldOffset(76)]
            internal uint reserved2;

            [FieldOffset(80)]
            internal int request_fd;

            [FieldOffset(80)]
            internal uint reserved;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN11v4l2_bufferC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial struct M
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint offset;

                [FieldOffset(0)]
                internal ulong userptr;

                [FieldOffset(0)]
                internal __IntPtr planes;

                [FieldOffset(0)]
                internal int fd;

                [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN11v4l2_bufferUt_C2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
            }

            private M.__Internal __instance;
            internal M.__Internal __Instance { get { return __instance; } }

            internal static M __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new M(native.ToPointer(), skipVTables);
            }

            internal static M __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new M(native, skipVTables);
            }

            private M(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private M(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::V4l2.AutoGen.V4l2Buffer.M.__Internal*) native;
            }

            public M(global::V4l2.AutoGen.V4l2Buffer.M __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            public uint Offset
            {
                get
                {
                    return __instance.offset;
                }

                set
                {
                    __instance.offset = value;
                }
            }

            public ulong Userptr
            {
                get
                {
                    return __instance.userptr;
                }

                set
                {
                    __instance.userptr = value;
                }
            }

            public global::V4l2.AutoGen.V4l2Plane Planes
            {
                get
                {
                    var __result0 = global::V4l2.AutoGen.V4l2Plane.__GetOrCreateInstance(__instance.planes, false);
                    return __result0;
                }

                set
                {
                    __instance.planes = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            public int Fd
            {
                get
                {
                    return __instance.fd;
                }

                set
                {
                    __instance.fd = value;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Buffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Buffer>();

        protected bool __ownsNativeInstance;

        internal static V4l2Buffer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Buffer(native.ToPointer(), skipVTables);
        }

        internal static V4l2Buffer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Buffer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Buffer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Buffer(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Buffer(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Buffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Buffer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Buffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Buffer(global::V4l2.AutoGen.V4l2Buffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Buffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Buffer.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Buffer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Bytesused
        {
            get
            {
                return ((__Internal*)__Instance)->bytesused;
            }

            set
            {
                ((__Internal*)__Instance)->bytesused = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public uint Field
        {
            get
            {
                return ((__Internal*)__Instance)->field;
            }

            set
            {
                ((__Internal*)__Instance)->field = value;
            }
        }

        public global::V4l2.AutoGen.V4l2Timecode Timecode
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Timecode.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->timecode));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->timecode = *(global::V4l2.AutoGen.V4l2Timecode.__Internal*) value.__Instance;
            }
        }

        public uint Sequence
        {
            get
            {
                return ((__Internal*)__Instance)->sequence;
            }

            set
            {
                ((__Internal*)__Instance)->sequence = value;
            }
        }

        public uint Memory
        {
            get
            {
                return ((__Internal*)__Instance)->memory;
            }

            set
            {
                ((__Internal*)__Instance)->memory = value;
            }
        }

        public global::V4l2.AutoGen.V4l2Buffer.M m
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Buffer.M.__CreateInstance(((__Internal*)__Instance)->m);
            }

            set
            {
                ((__Internal*)__Instance)->m = value.__Instance;
            }
        }

        public uint Length
        {
            get
            {
                return ((__Internal*)__Instance)->length;
            }

            set
            {
                ((__Internal*)__Instance)->length = value;
            }
        }

        public uint Reserved2
        {
            get
            {
                return ((__Internal*)__Instance)->reserved2;
            }

            set
            {
                ((__Internal*)__Instance)->reserved2 = value;
            }
        }

        public int RequestFd
        {
            get
            {
                return ((__Internal*)__Instance)->request_fd;
            }

            set
            {
                ((__Internal*)__Instance)->request_fd = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }
    }

    /// <summary>struct v4l2_exportbuffer - export of video buffer as DMABUF file descriptor</summary>
    /// <remarks>
    /// <para>id number of the buffer</para>
    /// <para>enum v4l2_buf_type; buffer type (type == *_MPLANE for</para>
    /// <para>multiplanar buffers);</para>
    /// <para>index of the plane to be exported, 0 for single plane queues</para>
    /// <para>flags for newly created file, currently only O_CLOEXEC is</para>
    /// <para>supported, refer to manual of open syscall for more details</para>
    /// <para>file descriptor associated with DMABUF (set by driver)</para>
    /// <para>drivers and applications must zero this array</para>
    /// <para>Contains data used for exporting a video buffer as DMABUF file descriptor.</para>
    /// <para>The buffer is identified by a 'cookie' returned by VIDIOC_QUERYBUF</para>
    /// <para>(identical to the cookie used to mmap() the buffer to userspace). All</para>
    /// <para>reserved fields must be set to zero. The field reserved0 is expected to</para>
    /// <para>become a structure 'type' allowing an alternative layout of the structure</para>
    /// <para>content. Therefore this field should not be used for any other extensions.</para>
    /// </remarks>
    public unsafe partial class V4l2Exportbuffer : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal uint type;
            internal uint index;
            internal uint plane;
            internal uint flags;
            internal int fd;
            internal fixed uint reserved[11];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN17v4l2_exportbufferC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Exportbuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Exportbuffer>();

        protected bool __ownsNativeInstance;

        internal static V4l2Exportbuffer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Exportbuffer(native.ToPointer(), skipVTables);
        }

        internal static V4l2Exportbuffer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Exportbuffer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Exportbuffer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Exportbuffer(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Exportbuffer(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Exportbuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Exportbuffer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Exportbuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Exportbuffer(global::V4l2.AutoGen.V4l2Exportbuffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Exportbuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Exportbuffer.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Exportbuffer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public uint Plane
        {
            get
            {
                return ((__Internal*)__Instance)->plane;
            }

            set
            {
                ((__Internal*)__Instance)->plane = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public int Fd
        {
            get
            {
                return ((__Internal*)__Instance)->fd;
            }

            set
            {
                ((__Internal*)__Instance)->fd = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 11);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 11; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2Framebuffer : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal uint capability;
            internal uint flags;
            internal __IntPtr @base;
            internal global::V4l2.AutoGen.V4l2Framebuffer.Fmt.__Internal fmt;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN16v4l2_framebufferC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial class Fmt : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal uint width;
                internal uint height;
                internal uint pixelformat;
                internal uint field;
                internal uint bytesperline;
                internal uint sizeimage;
                internal uint colorspace;
                internal uint priv;

                [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN16v4l2_framebufferUt_C2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Framebuffer.Fmt> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Framebuffer.Fmt>();

            protected bool __ownsNativeInstance;

            internal static Fmt __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Fmt(native.ToPointer(), skipVTables);
            }

            internal static Fmt __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (Fmt)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static Fmt __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Fmt(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Fmt(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Fmt(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Fmt()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Framebuffer.Fmt.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Fmt(global::V4l2.AutoGen.V4l2Framebuffer.Fmt __0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Framebuffer.Fmt.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::V4l2.AutoGen.V4l2Framebuffer.Fmt.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Framebuffer.Fmt.__Internal*) __0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public uint Width
            {
                get
                {
                    return ((__Internal*)__Instance)->width;
                }

                set
                {
                    ((__Internal*)__Instance)->width = value;
                }
            }

            public uint Height
            {
                get
                {
                    return ((__Internal*)__Instance)->height;
                }

                set
                {
                    ((__Internal*)__Instance)->height = value;
                }
            }

            public uint Pixelformat
            {
                get
                {
                    return ((__Internal*)__Instance)->pixelformat;
                }

                set
                {
                    ((__Internal*)__Instance)->pixelformat = value;
                }
            }

            public uint Field
            {
                get
                {
                    return ((__Internal*)__Instance)->field;
                }

                set
                {
                    ((__Internal*)__Instance)->field = value;
                }
            }

            public uint Bytesperline
            {
                get
                {
                    return ((__Internal*)__Instance)->bytesperline;
                }

                set
                {
                    ((__Internal*)__Instance)->bytesperline = value;
                }
            }

            public uint Sizeimage
            {
                get
                {
                    return ((__Internal*)__Instance)->sizeimage;
                }

                set
                {
                    ((__Internal*)__Instance)->sizeimage = value;
                }
            }

            public uint Colorspace
            {
                get
                {
                    return ((__Internal*)__Instance)->colorspace;
                }

                set
                {
                    ((__Internal*)__Instance)->colorspace = value;
                }
            }

            public uint Priv
            {
                get
                {
                    return ((__Internal*)__Instance)->priv;
                }

                set
                {
                    ((__Internal*)__Instance)->priv = value;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Framebuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Framebuffer>();

        protected bool __ownsNativeInstance;

        internal static V4l2Framebuffer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Framebuffer(native.ToPointer(), skipVTables);
        }

        internal static V4l2Framebuffer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Framebuffer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Framebuffer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Framebuffer(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Framebuffer(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Framebuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Framebuffer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Framebuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Framebuffer(global::V4l2.AutoGen.V4l2Framebuffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Framebuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Framebuffer.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Framebuffer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Capability
        {
            get
            {
                return ((__Internal*)__Instance)->capability;
            }

            set
            {
                ((__Internal*)__Instance)->capability = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public __IntPtr Base
        {
            get
            {
                return ((__Internal*)__Instance)->@base;
            }

            set
            {
                ((__Internal*)__Instance)->@base = (__IntPtr) value;
            }
        }

        public global::V4l2.AutoGen.V4l2Framebuffer.Fmt fmt
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Framebuffer.Fmt.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->fmt));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->fmt = *(global::V4l2.AutoGen.V4l2Framebuffer.Fmt.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class V4l2Clip : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal global::V4l2.AutoGen.V4l2Rect.__Internal c;
            internal __IntPtr next;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN9v4l2_clipC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Clip> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Clip>();

        protected bool __ownsNativeInstance;

        internal static V4l2Clip __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Clip(native.ToPointer(), skipVTables);
        }

        internal static V4l2Clip __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Clip)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Clip __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Clip(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Clip(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Clip(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Clip()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Clip.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Clip(global::V4l2.AutoGen.V4l2Clip _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Clip.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Clip.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Clip.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::V4l2.AutoGen.V4l2Rect C
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Rect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->c));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->c = *(global::V4l2.AutoGen.V4l2Rect.__Internal*) value.__Instance;
            }
        }

        public global::V4l2.AutoGen.V4l2Clip Next
        {
            get
            {
                var __result0 = global::V4l2.AutoGen.V4l2Clip.__GetOrCreateInstance(((__Internal*)__Instance)->next, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->next = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class V4l2Window : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal global::V4l2.AutoGen.V4l2Rect.__Internal w;
            internal uint field;
            internal uint chromakey;
            internal __IntPtr clips;
            internal uint clipcount;
            internal __IntPtr bitmap;
            internal byte global_alpha;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN11v4l2_windowC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Window> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Window>();

        protected bool __ownsNativeInstance;

        internal static V4l2Window __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Window(native.ToPointer(), skipVTables);
        }

        internal static V4l2Window __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Window)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Window __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Window(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Window(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Window(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Window()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Window.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Window(global::V4l2.AutoGen.V4l2Window _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Window.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Window.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Window.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::V4l2.AutoGen.V4l2Rect W
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Rect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->w));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->w = *(global::V4l2.AutoGen.V4l2Rect.__Internal*) value.__Instance;
            }
        }

        public uint Field
        {
            get
            {
                return ((__Internal*)__Instance)->field;
            }

            set
            {
                ((__Internal*)__Instance)->field = value;
            }
        }

        public uint Chromakey
        {
            get
            {
                return ((__Internal*)__Instance)->chromakey;
            }

            set
            {
                ((__Internal*)__Instance)->chromakey = value;
            }
        }

        public global::V4l2.AutoGen.V4l2Clip Clips
        {
            get
            {
                var __result0 = global::V4l2.AutoGen.V4l2Clip.__GetOrCreateInstance(((__Internal*)__Instance)->clips, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->clips = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint Clipcount
        {
            get
            {
                return ((__Internal*)__Instance)->clipcount;
            }

            set
            {
                ((__Internal*)__Instance)->clipcount = value;
            }
        }

        public __IntPtr Bitmap
        {
            get
            {
                return ((__Internal*)__Instance)->bitmap;
            }

            set
            {
                ((__Internal*)__Instance)->bitmap = (__IntPtr) value;
            }
        }

        public byte GlobalAlpha
        {
            get
            {
                return ((__Internal*)__Instance)->global_alpha;
            }

            set
            {
                ((__Internal*)__Instance)->global_alpha = value;
            }
        }
    }

    public unsafe partial class V4l2Captureparm : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal uint capability;
            internal uint capturemode;
            internal global::V4l2.AutoGen.V4l2Fract.__Internal timeperframe;
            internal uint extendedmode;
            internal uint readbuffers;
            internal fixed uint reserved[4];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN16v4l2_captureparmC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Captureparm> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Captureparm>();

        protected bool __ownsNativeInstance;

        internal static V4l2Captureparm __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Captureparm(native.ToPointer(), skipVTables);
        }

        internal static V4l2Captureparm __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Captureparm)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Captureparm __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Captureparm(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Captureparm(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Captureparm(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Captureparm()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Captureparm.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Captureparm(global::V4l2.AutoGen.V4l2Captureparm _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Captureparm.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Captureparm.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Captureparm.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Capability
        {
            get
            {
                return ((__Internal*)__Instance)->capability;
            }

            set
            {
                ((__Internal*)__Instance)->capability = value;
            }
        }

        public uint Capturemode
        {
            get
            {
                return ((__Internal*)__Instance)->capturemode;
            }

            set
            {
                ((__Internal*)__Instance)->capturemode = value;
            }
        }

        public global::V4l2.AutoGen.V4l2Fract Timeperframe
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Fract.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->timeperframe));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->timeperframe = *(global::V4l2.AutoGen.V4l2Fract.__Internal*) value.__Instance;
            }
        }

        public uint Extendedmode
        {
            get
            {
                return ((__Internal*)__Instance)->extendedmode;
            }

            set
            {
                ((__Internal*)__Instance)->extendedmode = value;
            }
        }

        public uint Readbuffers
        {
            get
            {
                return ((__Internal*)__Instance)->readbuffers;
            }

            set
            {
                ((__Internal*)__Instance)->readbuffers = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2Outputparm : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal uint capability;
            internal uint outputmode;
            internal global::V4l2.AutoGen.V4l2Fract.__Internal timeperframe;
            internal uint extendedmode;
            internal uint writebuffers;
            internal fixed uint reserved[4];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN15v4l2_outputparmC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Outputparm> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Outputparm>();

        protected bool __ownsNativeInstance;

        internal static V4l2Outputparm __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Outputparm(native.ToPointer(), skipVTables);
        }

        internal static V4l2Outputparm __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Outputparm)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Outputparm __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Outputparm(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Outputparm(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Outputparm(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Outputparm()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Outputparm.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Outputparm(global::V4l2.AutoGen.V4l2Outputparm _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Outputparm.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Outputparm.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Outputparm.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Capability
        {
            get
            {
                return ((__Internal*)__Instance)->capability;
            }

            set
            {
                ((__Internal*)__Instance)->capability = value;
            }
        }

        public uint Outputmode
        {
            get
            {
                return ((__Internal*)__Instance)->outputmode;
            }

            set
            {
                ((__Internal*)__Instance)->outputmode = value;
            }
        }

        public global::V4l2.AutoGen.V4l2Fract Timeperframe
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Fract.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->timeperframe));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->timeperframe = *(global::V4l2.AutoGen.V4l2Fract.__Internal*) value.__Instance;
            }
        }

        public uint Extendedmode
        {
            get
            {
                return ((__Internal*)__Instance)->extendedmode;
            }

            set
            {
                ((__Internal*)__Instance)->extendedmode = value;
            }
        }

        public uint Writebuffers
        {
            get
            {
                return ((__Internal*)__Instance)->writebuffers;
            }

            set
            {
                ((__Internal*)__Instance)->writebuffers = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2Cropcap : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 44)]
        public partial struct __Internal
        {
            internal uint type;
            internal global::V4l2.AutoGen.V4l2Rect.__Internal bounds;
            internal global::V4l2.AutoGen.V4l2Rect.__Internal defrect;
            internal global::V4l2.AutoGen.V4l2Fract.__Internal pixelaspect;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN12v4l2_cropcapC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Cropcap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Cropcap>();

        protected bool __ownsNativeInstance;

        internal static V4l2Cropcap __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Cropcap(native.ToPointer(), skipVTables);
        }

        internal static V4l2Cropcap __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Cropcap)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Cropcap __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Cropcap(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Cropcap(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Cropcap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Cropcap()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Cropcap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Cropcap(global::V4l2.AutoGen.V4l2Cropcap _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Cropcap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Cropcap.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Cropcap.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public global::V4l2.AutoGen.V4l2Rect Bounds
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Rect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->bounds));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->bounds = *(global::V4l2.AutoGen.V4l2Rect.__Internal*) value.__Instance;
            }
        }

        public global::V4l2.AutoGen.V4l2Rect Defrect
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Rect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->defrect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->defrect = *(global::V4l2.AutoGen.V4l2Rect.__Internal*) value.__Instance;
            }
        }

        public global::V4l2.AutoGen.V4l2Fract Pixelaspect
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Fract.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->pixelaspect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->pixelaspect = *(global::V4l2.AutoGen.V4l2Fract.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class V4l2Crop : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            internal uint type;
            internal global::V4l2.AutoGen.V4l2Rect.__Internal c;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN9v4l2_cropC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Crop> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Crop>();

        protected bool __ownsNativeInstance;

        internal static V4l2Crop __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Crop(native.ToPointer(), skipVTables);
        }

        internal static V4l2Crop __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Crop)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Crop __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Crop(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Crop(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Crop(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Crop()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Crop.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Crop(global::V4l2.AutoGen.V4l2Crop _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Crop.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Crop.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Crop.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public global::V4l2.AutoGen.V4l2Rect C
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Rect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->c));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->c = *(global::V4l2.AutoGen.V4l2Rect.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>
    /// <para>struct v4l2_selection - selection info</para>
    /// <para>buffer type (do not use *_MPLANE types)</para>
    /// <para>Selection target, used to choose one of possible rectangles;</para>
    /// <para>defined in v4l2-common.h; V4L2_SEL_TGT_* .</para>
    /// <para>constraints flags, defined in v4l2-common.h; V4L2_SEL_FLAG_*.</para>
    /// <para>coordinates of selection window</para>
    /// <para>for future use, rounds structure size to 64 bytes, set to zero</para>
    /// </summary>
    /// <remarks>
    /// <para>Hardware may use multiple helper windows to process a video stream.</para>
    /// <para>The structure is used to exchange this selection areas between</para>
    /// <para>an application and a driver.</para>
    /// </remarks>
    public unsafe partial class V4l2Selection : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal uint type;
            internal uint target;
            internal uint flags;
            internal global::V4l2.AutoGen.V4l2Rect.__Internal r;
            internal fixed uint reserved[9];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN14v4l2_selectionC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Selection> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Selection>();

        protected bool __ownsNativeInstance;

        internal static V4l2Selection __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Selection(native.ToPointer(), skipVTables);
        }

        internal static V4l2Selection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Selection)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Selection __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Selection(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Selection(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Selection(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Selection()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Selection.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Selection(global::V4l2.AutoGen.V4l2Selection _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Selection.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Selection.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Selection.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Target
        {
            get
            {
                return ((__Internal*)__Instance)->target;
            }

            set
            {
                ((__Internal*)__Instance)->target = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public global::V4l2.AutoGen.V4l2Rect R
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Rect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->r));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->r = *(global::V4l2.AutoGen.V4l2Rect.__Internal*) value.__Instance;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 9);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 9; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2Standard : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal uint index;
            internal ulong id;
            internal fixed byte name[24];
            internal global::V4l2.AutoGen.V4l2Fract.__Internal frameperiod;
            internal uint framelines;
            internal fixed uint reserved[4];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN13v4l2_standardC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Standard> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Standard>();

        protected bool __ownsNativeInstance;

        internal static V4l2Standard __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Standard(native.ToPointer(), skipVTables);
        }

        internal static V4l2Standard __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Standard)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Standard __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Standard(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Standard(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Standard(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Standard()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Standard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Standard(global::V4l2.AutoGen.V4l2Standard _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Standard.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Standard.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Standard.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public ulong Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        public byte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->name, 24);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 24; i++)
                        ((__Internal*)__Instance)->name[i] = value[i];
                }
            }
        }

        public global::V4l2.AutoGen.V4l2Fract Frameperiod
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Fract.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->frameperiod));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->frameperiod = *(global::V4l2.AutoGen.V4l2Fract.__Internal*) value.__Instance;
            }
        }

        public uint Framelines
        {
            get
            {
                return ((__Internal*)__Instance)->framelines;
            }

            set
            {
                ((__Internal*)__Instance)->framelines = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    /// <summary>
    /// <para>struct v4l2_bt_timings - BT.656/BT.1120 timing data</para>
    /// <para>total width of the active video in pixels</para>
    /// <para>total height of the active video in lines</para>
    /// <para>Interlaced or progressive</para>
    /// <para>Positive or negative polarities</para>
    /// <para>Pixel clock in HZ. Ex. 74.25MHz-&gt;74250000</para>
    /// <para>front porch in pixels</para>
    /// <para>Horizontal Sync length in pixels</para>
    /// <para>Horizontal back porch in pixels</para>
    /// <para>front porch in lines</para>
    /// <para>Vertical Sync length in lines</para>
    /// <para>Vertical back porch in lines</para>
    /// </summary>
    /// <remarks>
    /// <para>(aka field 2) of interlaced field formats</para>
    /// <para>(aka field 2) of interlaced field formats</para>
    /// <para>(aka field 2) of interlaced field formats</para>
    /// <para>Standards the timing belongs to</para>
    /// <para>Flags</para>
    /// <para>The picture aspect ratio (hor/vert).</para>
    /// <para>VIC code as per the CEA-861 standard.</para>
    /// <para>VIC code as per the HDMI standard.</para>
    /// <para>Reserved fields, must be zeroed.</para>
    /// <para>A note regarding vertical interlaced timings: height refers to the total</para>
    /// <para>height of the active video frame (= two fields). The blanking timings refer</para>
    /// <para>to the blanking of each field. So the height of the total frame is</para>
    /// <para>calculated as follows:</para>
    /// <para>tot_height = height + vfrontporch + vsync + vbackporch +</para>
    /// <para>il_vfrontporch + il_vsync + il_vbackporch</para>
    /// <para>The active height of each field is height / 2.</para>
    /// </remarks>
    public unsafe partial class V4l2BtTimings : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 124)]
        public partial struct __Internal
        {
            internal uint width;
            internal uint height;
            internal uint interlaced;
            internal uint polarities;
            internal ulong pixelclock;
            internal uint hfrontporch;
            internal uint hsync;
            internal uint hbackporch;
            internal uint vfrontporch;
            internal uint vsync;
            internal uint vbackporch;
            internal uint il_vfrontporch;
            internal uint il_vsync;
            internal uint il_vbackporch;
            internal uint standards;
            internal uint flags;
            internal global::V4l2.AutoGen.V4l2Fract.__Internal picture_aspect;
            internal byte cea861_vic;
            internal byte hdmi_vic;
            internal fixed byte reserved[46];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN15v4l2_bt_timingsC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2BtTimings> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2BtTimings>();

        protected bool __ownsNativeInstance;

        internal static V4l2BtTimings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2BtTimings(native.ToPointer(), skipVTables);
        }

        internal static V4l2BtTimings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2BtTimings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2BtTimings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2BtTimings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2BtTimings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2BtTimings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2BtTimings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2BtTimings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2BtTimings(global::V4l2.AutoGen.V4l2BtTimings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2BtTimings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2BtTimings.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2BtTimings.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public uint Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        public uint Interlaced
        {
            get
            {
                return ((__Internal*)__Instance)->interlaced;
            }

            set
            {
                ((__Internal*)__Instance)->interlaced = value;
            }
        }

        public uint Polarities
        {
            get
            {
                return ((__Internal*)__Instance)->polarities;
            }

            set
            {
                ((__Internal*)__Instance)->polarities = value;
            }
        }

        public ulong Pixelclock
        {
            get
            {
                return ((__Internal*)__Instance)->pixelclock;
            }

            set
            {
                ((__Internal*)__Instance)->pixelclock = value;
            }
        }

        public uint Hfrontporch
        {
            get
            {
                return ((__Internal*)__Instance)->hfrontporch;
            }

            set
            {
                ((__Internal*)__Instance)->hfrontporch = value;
            }
        }

        public uint Hsync
        {
            get
            {
                return ((__Internal*)__Instance)->hsync;
            }

            set
            {
                ((__Internal*)__Instance)->hsync = value;
            }
        }

        public uint Hbackporch
        {
            get
            {
                return ((__Internal*)__Instance)->hbackporch;
            }

            set
            {
                ((__Internal*)__Instance)->hbackporch = value;
            }
        }

        public uint Vfrontporch
        {
            get
            {
                return ((__Internal*)__Instance)->vfrontporch;
            }

            set
            {
                ((__Internal*)__Instance)->vfrontporch = value;
            }
        }

        public uint Vsync
        {
            get
            {
                return ((__Internal*)__Instance)->vsync;
            }

            set
            {
                ((__Internal*)__Instance)->vsync = value;
            }
        }

        public uint Vbackporch
        {
            get
            {
                return ((__Internal*)__Instance)->vbackporch;
            }

            set
            {
                ((__Internal*)__Instance)->vbackporch = value;
            }
        }

        public uint IlVfrontporch
        {
            get
            {
                return ((__Internal*)__Instance)->il_vfrontporch;
            }

            set
            {
                ((__Internal*)__Instance)->il_vfrontporch = value;
            }
        }

        public uint IlVsync
        {
            get
            {
                return ((__Internal*)__Instance)->il_vsync;
            }

            set
            {
                ((__Internal*)__Instance)->il_vsync = value;
            }
        }

        public uint IlVbackporch
        {
            get
            {
                return ((__Internal*)__Instance)->il_vbackporch;
            }

            set
            {
                ((__Internal*)__Instance)->il_vbackporch = value;
            }
        }

        public uint Standards
        {
            get
            {
                return ((__Internal*)__Instance)->standards;
            }

            set
            {
                ((__Internal*)__Instance)->standards = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public global::V4l2.AutoGen.V4l2Fract PictureAspect
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Fract.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->picture_aspect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->picture_aspect = *(global::V4l2.AutoGen.V4l2Fract.__Internal*) value.__Instance;
            }
        }

        public byte Cea861Vic
        {
            get
            {
                return ((__Internal*)__Instance)->cea861_vic;
            }

            set
            {
                ((__Internal*)__Instance)->cea861_vic = value;
            }
        }

        public byte HdmiVic
        {
            get
            {
                return ((__Internal*)__Instance)->hdmi_vic;
            }

            set
            {
                ((__Internal*)__Instance)->hdmi_vic = value;
            }
        }

        public byte[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->reserved, 46);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 46; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    /// <summary>
    /// <para>struct v4l2_dv_timings - DV timings</para>
    /// <para>the type of the timings</para>
    /// <para> <c>:</c> BT656/1120 timings</para>
    /// </summary>
    public unsafe partial class V4l2DvTimings : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 132)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint type;

            [FieldOffset(4)]
            internal global::V4l2.AutoGen.V4l2BtTimings.__Internal bt;

            [FieldOffset(4)]
            internal fixed uint reserved[32];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN15v4l2_dv_timingsC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2DvTimings> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2DvTimings>();

        protected bool __ownsNativeInstance;

        internal static V4l2DvTimings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2DvTimings(native.ToPointer(), skipVTables);
        }

        internal static V4l2DvTimings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2DvTimings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2DvTimings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2DvTimings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2DvTimings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2DvTimings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2DvTimings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2DvTimings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2DvTimings(global::V4l2.AutoGen.V4l2DvTimings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2DvTimings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2DvTimings.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2DvTimings.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public global::V4l2.AutoGen.V4l2BtTimings Bt
        {
            get
            {
                return global::V4l2.AutoGen.V4l2BtTimings.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->bt));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->bt = *(global::V4l2.AutoGen.V4l2BtTimings.__Internal*) value.__Instance;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    /// <summary>
    /// <para>struct v4l2_enum_dv_timings - DV timings enumeration</para>
    /// <para>enumeration index</para>
    /// </summary>
    /// <remarks>
    /// <para>:	the pad number for which to enumerate timings (used with</para>
    /// <para>v4l-subdev nodes only)</para>
    /// <para>:	must be zeroed</para>
    /// <para>:	the timings for the given index</para>
    /// </remarks>
    public unsafe partial class V4l2EnumDvTimings : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 148)]
        public partial struct __Internal
        {
            internal uint index;
            internal uint pad;
            internal fixed uint reserved[2];
            internal global::V4l2.AutoGen.V4l2DvTimings.__Internal timings;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN20v4l2_enum_dv_timingsC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EnumDvTimings> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EnumDvTimings>();

        protected bool __ownsNativeInstance;

        internal static V4l2EnumDvTimings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2EnumDvTimings(native.ToPointer(), skipVTables);
        }

        internal static V4l2EnumDvTimings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2EnumDvTimings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2EnumDvTimings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2EnumDvTimings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2EnumDvTimings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2EnumDvTimings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2EnumDvTimings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EnumDvTimings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2EnumDvTimings(global::V4l2.AutoGen.V4l2EnumDvTimings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EnumDvTimings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2EnumDvTimings.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2EnumDvTimings.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public uint Pad
        {
            get
            {
                return ((__Internal*)__Instance)->pad;
            }

            set
            {
                ((__Internal*)__Instance)->pad = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }

        public global::V4l2.AutoGen.V4l2DvTimings Timings
        {
            get
            {
                return global::V4l2.AutoGen.V4l2DvTimings.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->timings));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->timings = *(global::V4l2.AutoGen.V4l2DvTimings.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>
    /// <para>struct v4l2_bt_timings_cap - BT.656/BT.1120 timing capabilities</para>
    /// <para>width in pixels</para>
    /// <para>width in pixels</para>
    /// <para>height in lines</para>
    /// <para>height in lines</para>
    /// <para>Pixel clock in HZ. Ex. 74.25MHz-&gt;74250000</para>
    /// <para>Pixel clock in HZ. Ex. 74.25MHz-&gt;74250000</para>
    /// <para>Supported standards</para>
    /// <para>Supported capabilities</para>
    /// <para>Must be zeroed</para>
    /// </summary>
    public unsafe partial class V4l2BtTimingsCap : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 104)]
        public partial struct __Internal
        {
            internal uint min_width;
            internal uint max_width;
            internal uint min_height;
            internal uint max_height;
            internal ulong min_pixelclock;
            internal ulong max_pixelclock;
            internal uint standards;
            internal uint capabilities;
            internal fixed uint reserved[16];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN19v4l2_bt_timings_capC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2BtTimingsCap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2BtTimingsCap>();

        protected bool __ownsNativeInstance;

        internal static V4l2BtTimingsCap __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2BtTimingsCap(native.ToPointer(), skipVTables);
        }

        internal static V4l2BtTimingsCap __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2BtTimingsCap)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2BtTimingsCap __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2BtTimingsCap(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2BtTimingsCap(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2BtTimingsCap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2BtTimingsCap()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2BtTimingsCap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2BtTimingsCap(global::V4l2.AutoGen.V4l2BtTimingsCap _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2BtTimingsCap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2BtTimingsCap.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2BtTimingsCap.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint MinWidth
        {
            get
            {
                return ((__Internal*)__Instance)->min_width;
            }

            set
            {
                ((__Internal*)__Instance)->min_width = value;
            }
        }

        public uint MaxWidth
        {
            get
            {
                return ((__Internal*)__Instance)->max_width;
            }

            set
            {
                ((__Internal*)__Instance)->max_width = value;
            }
        }

        public uint MinHeight
        {
            get
            {
                return ((__Internal*)__Instance)->min_height;
            }

            set
            {
                ((__Internal*)__Instance)->min_height = value;
            }
        }

        public uint MaxHeight
        {
            get
            {
                return ((__Internal*)__Instance)->max_height;
            }

            set
            {
                ((__Internal*)__Instance)->max_height = value;
            }
        }

        public ulong MinPixelclock
        {
            get
            {
                return ((__Internal*)__Instance)->min_pixelclock;
            }

            set
            {
                ((__Internal*)__Instance)->min_pixelclock = value;
            }
        }

        public ulong MaxPixelclock
        {
            get
            {
                return ((__Internal*)__Instance)->max_pixelclock;
            }

            set
            {
                ((__Internal*)__Instance)->max_pixelclock = value;
            }
        }

        public uint Standards
        {
            get
            {
                return ((__Internal*)__Instance)->standards;
            }

            set
            {
                ((__Internal*)__Instance)->standards = value;
            }
        }

        public uint Capabilities
        {
            get
            {
                return ((__Internal*)__Instance)->capabilities;
            }

            set
            {
                ((__Internal*)__Instance)->capabilities = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    /// <summary>
    /// <para>struct v4l2_dv_timings_cap - DV timings capabilities</para>
    /// <para>the type of the timings (same as in struct v4l2_dv_timings)</para>
    /// </summary>
    /// <remarks>
    /// <para>:	the pad number for which to query capabilities (used with</para>
    /// <para>v4l-subdev nodes only)</para>
    /// <para> <c>:</c> the BT656/1120 timings capabilities</para>
    /// </remarks>
    public unsafe partial class V4l2DvTimingsCap : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 144)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint type;

            [FieldOffset(4)]
            internal uint pad;

            [FieldOffset(8)]
            internal fixed uint reserved[2];

            [FieldOffset(16)]
            internal global::V4l2.AutoGen.V4l2BtTimingsCap.__Internal bt;

            [FieldOffset(16)]
            internal fixed uint raw_data[32];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN19v4l2_dv_timings_capC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2DvTimingsCap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2DvTimingsCap>();

        protected bool __ownsNativeInstance;

        internal static V4l2DvTimingsCap __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2DvTimingsCap(native.ToPointer(), skipVTables);
        }

        internal static V4l2DvTimingsCap __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2DvTimingsCap)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2DvTimingsCap __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2DvTimingsCap(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2DvTimingsCap(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2DvTimingsCap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2DvTimingsCap()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2DvTimingsCap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2DvTimingsCap(global::V4l2.AutoGen.V4l2DvTimingsCap _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2DvTimingsCap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2DvTimingsCap.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2DvTimingsCap.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Pad
        {
            get
            {
                return ((__Internal*)__Instance)->pad;
            }

            set
            {
                ((__Internal*)__Instance)->pad = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }

        public global::V4l2.AutoGen.V4l2BtTimingsCap Bt
        {
            get
            {
                return global::V4l2.AutoGen.V4l2BtTimingsCap.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->bt));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->bt = *(global::V4l2.AutoGen.V4l2BtTimingsCap.__Internal*) value.__Instance;
            }
        }

        public uint[] RawData
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->raw_data, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->raw_data[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2Input : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 80)]
        public partial struct __Internal
        {
            internal uint index;
            internal fixed byte name[32];
            internal uint type;
            internal uint audioset;
            internal uint tuner;
            internal ulong std;
            internal uint status;
            internal uint capabilities;
            internal fixed uint reserved[3];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN10v4l2_inputC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Input> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Input>();

        protected bool __ownsNativeInstance;

        internal static V4l2Input __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Input(native.ToPointer(), skipVTables);
        }

        internal static V4l2Input __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Input)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Input __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Input(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Input(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Input(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Input()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Input.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Input(global::V4l2.AutoGen.V4l2Input _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Input.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Input.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Input.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public byte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->name, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->name[i] = value[i];
                }
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Audioset
        {
            get
            {
                return ((__Internal*)__Instance)->audioset;
            }

            set
            {
                ((__Internal*)__Instance)->audioset = value;
            }
        }

        public uint Tuner
        {
            get
            {
                return ((__Internal*)__Instance)->tuner;
            }

            set
            {
                ((__Internal*)__Instance)->tuner = value;
            }
        }

        public ulong Std
        {
            get
            {
                return ((__Internal*)__Instance)->std;
            }

            set
            {
                ((__Internal*)__Instance)->std = value;
            }
        }

        public uint Status
        {
            get
            {
                return ((__Internal*)__Instance)->status;
            }

            set
            {
                ((__Internal*)__Instance)->status = value;
            }
        }

        public uint Capabilities
        {
            get
            {
                return ((__Internal*)__Instance)->capabilities;
            }

            set
            {
                ((__Internal*)__Instance)->capabilities = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2Output : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal uint index;
            internal fixed byte name[32];
            internal uint type;
            internal uint audioset;
            internal uint modulator;
            internal ulong std;
            internal uint capabilities;
            internal fixed uint reserved[3];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN11v4l2_outputC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Output> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Output>();

        protected bool __ownsNativeInstance;

        internal static V4l2Output __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Output(native.ToPointer(), skipVTables);
        }

        internal static V4l2Output __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Output)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Output __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Output(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Output(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Output(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Output()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Output.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Output(global::V4l2.AutoGen.V4l2Output _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Output.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Output.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Output.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public byte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->name, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->name[i] = value[i];
                }
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Audioset
        {
            get
            {
                return ((__Internal*)__Instance)->audioset;
            }

            set
            {
                ((__Internal*)__Instance)->audioset = value;
            }
        }

        public uint Modulator
        {
            get
            {
                return ((__Internal*)__Instance)->modulator;
            }

            set
            {
                ((__Internal*)__Instance)->modulator = value;
            }
        }

        public ulong Std
        {
            get
            {
                return ((__Internal*)__Instance)->std;
            }

            set
            {
                ((__Internal*)__Instance)->std = value;
            }
        }

        public uint Capabilities
        {
            get
            {
                return ((__Internal*)__Instance)->capabilities;
            }

            set
            {
                ((__Internal*)__Instance)->capabilities = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2Control : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal uint id;
            internal int value;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN12v4l2_controlC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Control> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Control>();

        protected bool __ownsNativeInstance;

        internal static V4l2Control __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Control(native.ToPointer(), skipVTables);
        }

        internal static V4l2Control __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Control)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Control __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Control(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Control(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Control(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Control()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Control.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Control(global::V4l2.AutoGen.V4l2Control _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Control.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Control.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Control.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        public int Value
        {
            get
            {
                return ((__Internal*)__Instance)->value;
            }

            set
            {
                ((__Internal*)__Instance)->value = value;
            }
        }
    }

    public unsafe partial class V4l2ExtControl : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint id;

            [FieldOffset(4)]
            internal uint size;

            [FieldOffset(8)]
            internal fixed uint reserved2[1];

            [FieldOffset(12)]
            internal int value;

            [FieldOffset(12)]
            internal long value64;

            [FieldOffset(12)]
            internal __IntPtr @string;

            [FieldOffset(12)]
            internal __IntPtr p_u8;

            [FieldOffset(12)]
            internal __IntPtr p_u16;

            [FieldOffset(12)]
            internal __IntPtr p_u32;

            [FieldOffset(12)]
            internal __IntPtr p_area;

            [FieldOffset(12)]
            internal __IntPtr p_h264_sps;

            [FieldOffset(12)]
            internal __IntPtr p_h264_pps;

            [FieldOffset(12)]
            internal __IntPtr p_h264_scaling_matrix;

            [FieldOffset(12)]
            internal __IntPtr p_h264_pred_weights;

            [FieldOffset(12)]
            internal __IntPtr p_h264_slice_params;

            [FieldOffset(12)]
            internal __IntPtr p_h264_decode_params;

            [FieldOffset(12)]
            internal __IntPtr p_fwht_params;

            [FieldOffset(12)]
            internal __IntPtr p_vp8_frame;

            [FieldOffset(12)]
            internal __IntPtr p_mpeg2_sequence;

            [FieldOffset(12)]
            internal __IntPtr p_mpeg2_picture;

            [FieldOffset(12)]
            internal __IntPtr p_mpeg2_quantisation;

            [FieldOffset(12)]
            internal __IntPtr ptr;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN16v4l2_ext_controlC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2ExtControl> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2ExtControl>();

        protected bool __ownsNativeInstance;

        internal static V4l2ExtControl __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2ExtControl(native.ToPointer(), skipVTables);
        }

        internal static V4l2ExtControl __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2ExtControl)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2ExtControl __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2ExtControl(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2ExtControl(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2ExtControl(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2ExtControl()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2ExtControl.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2ExtControl(global::V4l2.AutoGen.V4l2ExtControl _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2ExtControl.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2ExtControl.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2ExtControl.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        public uint Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }

        public uint[] Reserved2
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved2, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->reserved2[i] = value[i];
                }
            }
        }

        public int Value
        {
            get
            {
                return ((__Internal*)__Instance)->value;
            }

            set
            {
                ((__Internal*)__Instance)->value = value;
            }
        }

        public long Value64
        {
            get
            {
                return ((__Internal*)__Instance)->value64;
            }

            set
            {
                ((__Internal*)__Instance)->value64 = value;
            }
        }

        public sbyte* String
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->@string;
            }

            set
            {
                ((__Internal*)__Instance)->@string = (__IntPtr) value;
            }
        }

        public byte* PU8
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->p_u8;
            }

            set
            {
                ((__Internal*)__Instance)->p_u8 = (__IntPtr) value;
            }
        }

        public ushort* PU16
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->p_u16;
            }

            set
            {
                ((__Internal*)__Instance)->p_u16 = (__IntPtr) value;
            }
        }

        public uint* PU32
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->p_u32;
            }

            set
            {
                ((__Internal*)__Instance)->p_u32 = (__IntPtr) value;
            }
        }

        public global::V4l2.AutoGen.V4l2Area PArea
        {
            get
            {
                var __result0 = global::V4l2.AutoGen.V4l2Area.__GetOrCreateInstance(((__Internal*)__Instance)->p_area, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->p_area = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public __IntPtr Ptr
        {
            get
            {
                return ((__Internal*)__Instance)->ptr;
            }

            set
            {
                ((__Internal*)__Instance)->ptr = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class V4l2ExtControls : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint ctrl_class;

            [FieldOffset(0)]
            internal uint which;

            [FieldOffset(4)]
            internal uint count;

            [FieldOffset(8)]
            internal uint error_idx;

            [FieldOffset(12)]
            internal int request_fd;

            [FieldOffset(16)]
            internal fixed uint reserved[1];

            [FieldOffset(24)]
            internal __IntPtr controls;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN17v4l2_ext_controlsC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2ExtControls> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2ExtControls>();

        protected bool __ownsNativeInstance;

        internal static V4l2ExtControls __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2ExtControls(native.ToPointer(), skipVTables);
        }

        internal static V4l2ExtControls __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2ExtControls)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2ExtControls __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2ExtControls(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2ExtControls(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2ExtControls(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2ExtControls()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2ExtControls.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2ExtControls(global::V4l2.AutoGen.V4l2ExtControls _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2ExtControls.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2ExtControls.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2ExtControls.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint CtrlClass
        {
            get
            {
                return ((__Internal*)__Instance)->ctrl_class;
            }

            set
            {
                ((__Internal*)__Instance)->ctrl_class = value;
            }
        }

        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        public uint ErrorIdx
        {
            get
            {
                return ((__Internal*)__Instance)->error_idx;
            }

            set
            {
                ((__Internal*)__Instance)->error_idx = value;
            }
        }

        public int RequestFd
        {
            get
            {
                return ((__Internal*)__Instance)->request_fd;
            }

            set
            {
                ((__Internal*)__Instance)->request_fd = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }

        public global::V4l2.AutoGen.V4l2ExtControl Controls
        {
            get
            {
                var __result0 = global::V4l2.AutoGen.V4l2ExtControl.__GetOrCreateInstance(((__Internal*)__Instance)->controls, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->controls = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class V4l2Queryctrl : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 68)]
        public partial struct __Internal
        {
            internal uint id;
            internal uint type;
            internal fixed byte name[32];
            internal int minimum;
            internal int maximum;
            internal int step;
            internal int default_value;
            internal uint flags;
            internal fixed uint reserved[2];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN14v4l2_queryctrlC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Queryctrl> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Queryctrl>();

        protected bool __ownsNativeInstance;

        internal static V4l2Queryctrl __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Queryctrl(native.ToPointer(), skipVTables);
        }

        internal static V4l2Queryctrl __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Queryctrl)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Queryctrl __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Queryctrl(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Queryctrl(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Queryctrl(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Queryctrl()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Queryctrl.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Queryctrl(global::V4l2.AutoGen.V4l2Queryctrl _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Queryctrl.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Queryctrl.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Queryctrl.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public byte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->name, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->name[i] = value[i];
                }
            }
        }

        public int Minimum
        {
            get
            {
                return ((__Internal*)__Instance)->minimum;
            }

            set
            {
                ((__Internal*)__Instance)->minimum = value;
            }
        }

        public int Maximum
        {
            get
            {
                return ((__Internal*)__Instance)->maximum;
            }

            set
            {
                ((__Internal*)__Instance)->maximum = value;
            }
        }

        public int Step
        {
            get
            {
                return ((__Internal*)__Instance)->step;
            }

            set
            {
                ((__Internal*)__Instance)->step = value;
            }
        }

        public int DefaultValue
        {
            get
            {
                return ((__Internal*)__Instance)->default_value;
            }

            set
            {
                ((__Internal*)__Instance)->default_value = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2QueryExtCtrl : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 232)]
        public partial struct __Internal
        {
            internal uint id;
            internal uint type;
            internal fixed sbyte name[32];
            internal long minimum;
            internal long maximum;
            internal ulong step;
            internal long default_value;
            internal uint flags;
            internal uint elem_size;
            internal uint elems;
            internal uint nr_of_dims;
            internal fixed uint dims[4];
            internal fixed uint reserved[32];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN19v4l2_query_ext_ctrlC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2QueryExtCtrl> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2QueryExtCtrl>();

        protected bool __ownsNativeInstance;

        internal static V4l2QueryExtCtrl __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2QueryExtCtrl(native.ToPointer(), skipVTables);
        }

        internal static V4l2QueryExtCtrl __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2QueryExtCtrl)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2QueryExtCtrl __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2QueryExtCtrl(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2QueryExtCtrl(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2QueryExtCtrl(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2QueryExtCtrl()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2QueryExtCtrl.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2QueryExtCtrl(global::V4l2.AutoGen.V4l2QueryExtCtrl _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2QueryExtCtrl.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2QueryExtCtrl.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2QueryExtCtrl.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->name, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->name[i] = value[i];
                }
            }
        }

        public long Minimum
        {
            get
            {
                return ((__Internal*)__Instance)->minimum;
            }

            set
            {
                ((__Internal*)__Instance)->minimum = value;
            }
        }

        public long Maximum
        {
            get
            {
                return ((__Internal*)__Instance)->maximum;
            }

            set
            {
                ((__Internal*)__Instance)->maximum = value;
            }
        }

        public ulong Step
        {
            get
            {
                return ((__Internal*)__Instance)->step;
            }

            set
            {
                ((__Internal*)__Instance)->step = value;
            }
        }

        public long DefaultValue
        {
            get
            {
                return ((__Internal*)__Instance)->default_value;
            }

            set
            {
                ((__Internal*)__Instance)->default_value = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public uint ElemSize
        {
            get
            {
                return ((__Internal*)__Instance)->elem_size;
            }

            set
            {
                ((__Internal*)__Instance)->elem_size = value;
            }
        }

        public uint Elems
        {
            get
            {
                return ((__Internal*)__Instance)->elems;
            }

            set
            {
                ((__Internal*)__Instance)->elems = value;
            }
        }

        public uint NrOfDims
        {
            get
            {
                return ((__Internal*)__Instance)->nr_of_dims;
            }

            set
            {
                ((__Internal*)__Instance)->nr_of_dims = value;
            }
        }

        public uint[] Dims
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->dims, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->dims[i] = value[i];
                }
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2Querymenu : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 44)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint id;

            [FieldOffset(4)]
            internal uint index;

            [FieldOffset(8)]
            internal fixed byte name[32];

            [FieldOffset(8)]
            internal long value;

            [FieldOffset(40)]
            internal uint reserved;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN14v4l2_querymenuC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Querymenu> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Querymenu>();

        protected bool __ownsNativeInstance;

        internal static V4l2Querymenu __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Querymenu(native.ToPointer(), skipVTables);
        }

        internal static V4l2Querymenu __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Querymenu)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Querymenu __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Querymenu(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Querymenu(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Querymenu(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Querymenu()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Querymenu.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Querymenu(global::V4l2.AutoGen.V4l2Querymenu _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Querymenu.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Querymenu.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Querymenu.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public byte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->name, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->name[i] = value[i];
                }
            }
        }

        public long Value
        {
            get
            {
                return ((__Internal*)__Instance)->value;
            }

            set
            {
                ((__Internal*)__Instance)->value = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }
    }

    public unsafe partial class V4l2Tuner : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 84)]
        public partial struct __Internal
        {
            internal uint index;
            internal fixed byte name[32];
            internal uint type;
            internal uint capability;
            internal uint rangelow;
            internal uint rangehigh;
            internal uint rxsubchans;
            internal uint audmode;
            internal int signal;
            internal int afc;
            internal fixed uint reserved[4];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN10v4l2_tunerC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Tuner> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Tuner>();

        protected bool __ownsNativeInstance;

        internal static V4l2Tuner __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Tuner(native.ToPointer(), skipVTables);
        }

        internal static V4l2Tuner __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Tuner)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Tuner __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Tuner(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Tuner(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Tuner(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Tuner()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Tuner.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Tuner(global::V4l2.AutoGen.V4l2Tuner _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Tuner.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Tuner.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Tuner.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public byte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->name, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->name[i] = value[i];
                }
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Capability
        {
            get
            {
                return ((__Internal*)__Instance)->capability;
            }

            set
            {
                ((__Internal*)__Instance)->capability = value;
            }
        }

        public uint Rangelow
        {
            get
            {
                return ((__Internal*)__Instance)->rangelow;
            }

            set
            {
                ((__Internal*)__Instance)->rangelow = value;
            }
        }

        public uint Rangehigh
        {
            get
            {
                return ((__Internal*)__Instance)->rangehigh;
            }

            set
            {
                ((__Internal*)__Instance)->rangehigh = value;
            }
        }

        public uint Rxsubchans
        {
            get
            {
                return ((__Internal*)__Instance)->rxsubchans;
            }

            set
            {
                ((__Internal*)__Instance)->rxsubchans = value;
            }
        }

        public uint Audmode
        {
            get
            {
                return ((__Internal*)__Instance)->audmode;
            }

            set
            {
                ((__Internal*)__Instance)->audmode = value;
            }
        }

        public int Signal
        {
            get
            {
                return ((__Internal*)__Instance)->signal;
            }

            set
            {
                ((__Internal*)__Instance)->signal = value;
            }
        }

        public int Afc
        {
            get
            {
                return ((__Internal*)__Instance)->afc;
            }

            set
            {
                ((__Internal*)__Instance)->afc = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2Modulator : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 68)]
        public partial struct __Internal
        {
            internal uint index;
            internal fixed byte name[32];
            internal uint capability;
            internal uint rangelow;
            internal uint rangehigh;
            internal uint txsubchans;
            internal uint type;
            internal fixed uint reserved[3];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN14v4l2_modulatorC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Modulator> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Modulator>();

        protected bool __ownsNativeInstance;

        internal static V4l2Modulator __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Modulator(native.ToPointer(), skipVTables);
        }

        internal static V4l2Modulator __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Modulator)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Modulator __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Modulator(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Modulator(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Modulator(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Modulator()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Modulator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Modulator(global::V4l2.AutoGen.V4l2Modulator _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Modulator.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Modulator.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Modulator.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public byte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->name, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->name[i] = value[i];
                }
            }
        }

        public uint Capability
        {
            get
            {
                return ((__Internal*)__Instance)->capability;
            }

            set
            {
                ((__Internal*)__Instance)->capability = value;
            }
        }

        public uint Rangelow
        {
            get
            {
                return ((__Internal*)__Instance)->rangelow;
            }

            set
            {
                ((__Internal*)__Instance)->rangelow = value;
            }
        }

        public uint Rangehigh
        {
            get
            {
                return ((__Internal*)__Instance)->rangehigh;
            }

            set
            {
                ((__Internal*)__Instance)->rangehigh = value;
            }
        }

        public uint Txsubchans
        {
            get
            {
                return ((__Internal*)__Instance)->txsubchans;
            }

            set
            {
                ((__Internal*)__Instance)->txsubchans = value;
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2Frequency : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 44)]
        public partial struct __Internal
        {
            internal uint tuner;
            internal uint type;
            internal uint frequency;
            internal fixed uint reserved[8];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN14v4l2_frequencyC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Frequency> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Frequency>();

        protected bool __ownsNativeInstance;

        internal static V4l2Frequency __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Frequency(native.ToPointer(), skipVTables);
        }

        internal static V4l2Frequency __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Frequency)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Frequency __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Frequency(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Frequency(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Frequency(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Frequency()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Frequency.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Frequency(global::V4l2.AutoGen.V4l2Frequency _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Frequency.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Frequency.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Frequency.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Tuner
        {
            get
            {
                return ((__Internal*)__Instance)->tuner;
            }

            set
            {
                ((__Internal*)__Instance)->tuner = value;
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Frequency
        {
            get
            {
                return ((__Internal*)__Instance)->frequency;
            }

            set
            {
                ((__Internal*)__Instance)->frequency = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2FrequencyBand : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal uint tuner;
            internal uint type;
            internal uint index;
            internal uint capability;
            internal uint rangelow;
            internal uint rangehigh;
            internal uint modulation;
            internal fixed uint reserved[9];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN19v4l2_frequency_bandC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2FrequencyBand> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2FrequencyBand>();

        protected bool __ownsNativeInstance;

        internal static V4l2FrequencyBand __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2FrequencyBand(native.ToPointer(), skipVTables);
        }

        internal static V4l2FrequencyBand __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2FrequencyBand)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2FrequencyBand __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2FrequencyBand(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2FrequencyBand(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2FrequencyBand(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2FrequencyBand()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2FrequencyBand.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2FrequencyBand(global::V4l2.AutoGen.V4l2FrequencyBand _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2FrequencyBand.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2FrequencyBand.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2FrequencyBand.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Tuner
        {
            get
            {
                return ((__Internal*)__Instance)->tuner;
            }

            set
            {
                ((__Internal*)__Instance)->tuner = value;
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public uint Capability
        {
            get
            {
                return ((__Internal*)__Instance)->capability;
            }

            set
            {
                ((__Internal*)__Instance)->capability = value;
            }
        }

        public uint Rangelow
        {
            get
            {
                return ((__Internal*)__Instance)->rangelow;
            }

            set
            {
                ((__Internal*)__Instance)->rangelow = value;
            }
        }

        public uint Rangehigh
        {
            get
            {
                return ((__Internal*)__Instance)->rangehigh;
            }

            set
            {
                ((__Internal*)__Instance)->rangehigh = value;
            }
        }

        public uint Modulation
        {
            get
            {
                return ((__Internal*)__Instance)->modulation;
            }

            set
            {
                ((__Internal*)__Instance)->modulation = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 9);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 9; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2HwFreqSeek : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal uint tuner;
            internal uint type;
            internal uint seek_upward;
            internal uint wrap_around;
            internal uint spacing;
            internal uint rangelow;
            internal uint rangehigh;
            internal fixed uint reserved[5];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN17v4l2_hw_freq_seekC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2HwFreqSeek> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2HwFreqSeek>();

        protected bool __ownsNativeInstance;

        internal static V4l2HwFreqSeek __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2HwFreqSeek(native.ToPointer(), skipVTables);
        }

        internal static V4l2HwFreqSeek __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2HwFreqSeek)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2HwFreqSeek __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2HwFreqSeek(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2HwFreqSeek(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2HwFreqSeek(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2HwFreqSeek()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2HwFreqSeek.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2HwFreqSeek(global::V4l2.AutoGen.V4l2HwFreqSeek _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2HwFreqSeek.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2HwFreqSeek.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2HwFreqSeek.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Tuner
        {
            get
            {
                return ((__Internal*)__Instance)->tuner;
            }

            set
            {
                ((__Internal*)__Instance)->tuner = value;
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint SeekUpward
        {
            get
            {
                return ((__Internal*)__Instance)->seek_upward;
            }

            set
            {
                ((__Internal*)__Instance)->seek_upward = value;
            }
        }

        public uint WrapAround
        {
            get
            {
                return ((__Internal*)__Instance)->wrap_around;
            }

            set
            {
                ((__Internal*)__Instance)->wrap_around = value;
            }
        }

        public uint Spacing
        {
            get
            {
                return ((__Internal*)__Instance)->spacing;
            }

            set
            {
                ((__Internal*)__Instance)->spacing = value;
            }
        }

        public uint Rangelow
        {
            get
            {
                return ((__Internal*)__Instance)->rangelow;
            }

            set
            {
                ((__Internal*)__Instance)->rangelow = value;
            }
        }

        public uint Rangehigh
        {
            get
            {
                return ((__Internal*)__Instance)->rangehigh;
            }

            set
            {
                ((__Internal*)__Instance)->rangehigh = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2RdsData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 3)]
        public partial struct __Internal
        {
            internal byte lsb;
            internal byte msb;
            internal byte block;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN13v4l2_rds_dataC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2RdsData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2RdsData>();

        protected bool __ownsNativeInstance;

        internal static V4l2RdsData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2RdsData(native.ToPointer(), skipVTables);
        }

        internal static V4l2RdsData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2RdsData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2RdsData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2RdsData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2RdsData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2RdsData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2RdsData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2RdsData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2RdsData(global::V4l2.AutoGen.V4l2RdsData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2RdsData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2RdsData.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2RdsData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte Lsb
        {
            get
            {
                return ((__Internal*)__Instance)->lsb;
            }

            set
            {
                ((__Internal*)__Instance)->lsb = value;
            }
        }

        public byte Msb
        {
            get
            {
                return ((__Internal*)__Instance)->msb;
            }

            set
            {
                ((__Internal*)__Instance)->msb = value;
            }
        }

        public byte Block
        {
            get
            {
                return ((__Internal*)__Instance)->block;
            }

            set
            {
                ((__Internal*)__Instance)->block = value;
            }
        }
    }

    public unsafe partial class V4l2Audio : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 52)]
        public partial struct __Internal
        {
            internal uint index;
            internal fixed byte name[32];
            internal uint capability;
            internal uint mode;
            internal fixed uint reserved[2];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN10v4l2_audioC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Audio> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Audio>();

        protected bool __ownsNativeInstance;

        internal static V4l2Audio __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Audio(native.ToPointer(), skipVTables);
        }

        internal static V4l2Audio __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Audio)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Audio __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Audio(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Audio(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Audio(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Audio()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Audio.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Audio(global::V4l2.AutoGen.V4l2Audio _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Audio.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Audio.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Audio.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public byte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->name, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->name[i] = value[i];
                }
            }
        }

        public uint Capability
        {
            get
            {
                return ((__Internal*)__Instance)->capability;
            }

            set
            {
                ((__Internal*)__Instance)->capability = value;
            }
        }

        public uint Mode
        {
            get
            {
                return ((__Internal*)__Instance)->mode;
            }

            set
            {
                ((__Internal*)__Instance)->mode = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2Audioout : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 52)]
        public partial struct __Internal
        {
            internal uint index;
            internal fixed byte name[32];
            internal uint capability;
            internal uint mode;
            internal fixed uint reserved[2];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN13v4l2_audiooutC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Audioout> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Audioout>();

        protected bool __ownsNativeInstance;

        internal static V4l2Audioout __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Audioout(native.ToPointer(), skipVTables);
        }

        internal static V4l2Audioout __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Audioout)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Audioout __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Audioout(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Audioout(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Audioout(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Audioout()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Audioout.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Audioout(global::V4l2.AutoGen.V4l2Audioout _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Audioout.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Audioout.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Audioout.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public byte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->name, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->name[i] = value[i];
                }
            }
        }

        public uint Capability
        {
            get
            {
                return ((__Internal*)__Instance)->capability;
            }

            set
            {
                ((__Internal*)__Instance)->capability = value;
            }
        }

        public uint Mode
        {
            get
            {
                return ((__Internal*)__Instance)->mode;
            }

            set
            {
                ((__Internal*)__Instance)->mode = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2EncIdxEntry : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal ulong offset;
            internal ulong pts;
            internal uint length;
            internal uint flags;
            internal fixed uint reserved[2];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN18v4l2_enc_idx_entryC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EncIdxEntry> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EncIdxEntry>();

        protected bool __ownsNativeInstance;

        internal static V4l2EncIdxEntry __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2EncIdxEntry(native.ToPointer(), skipVTables);
        }

        internal static V4l2EncIdxEntry __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2EncIdxEntry)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2EncIdxEntry __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2EncIdxEntry(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2EncIdxEntry(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2EncIdxEntry(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2EncIdxEntry()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EncIdxEntry.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2EncIdxEntry(global::V4l2.AutoGen.V4l2EncIdxEntry _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EncIdxEntry.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2EncIdxEntry.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2EncIdxEntry.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }

        public ulong Pts
        {
            get
            {
                return ((__Internal*)__Instance)->pts;
            }

            set
            {
                ((__Internal*)__Instance)->pts = value;
            }
        }

        public uint Length
        {
            get
            {
                return ((__Internal*)__Instance)->length;
            }

            set
            {
                ((__Internal*)__Instance)->length = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2EncIdx : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2072)]
        public partial struct __Internal
        {
            internal uint entries;
            internal uint entries_cap;
            internal fixed uint reserved[4];
            internal fixed byte entry[2048];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN12v4l2_enc_idxC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EncIdx> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EncIdx>();

        protected bool __ownsNativeInstance;

        internal static V4l2EncIdx __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2EncIdx(native.ToPointer(), skipVTables);
        }

        internal static V4l2EncIdx __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2EncIdx)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2EncIdx __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2EncIdx(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2EncIdx(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2EncIdx(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2EncIdx()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EncIdx.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2EncIdx(global::V4l2.AutoGen.V4l2EncIdx _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EncIdx.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2EncIdx.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2EncIdx.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Entries
        {
            get
            {
                return ((__Internal*)__Instance)->entries;
            }

            set
            {
                ((__Internal*)__Instance)->entries = value;
            }
        }

        public uint EntriesCap
        {
            get
            {
                return ((__Internal*)__Instance)->entries_cap;
            }

            set
            {
                ((__Internal*)__Instance)->entries_cap = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }

        public global::V4l2.AutoGen.V4l2EncIdxEntry[] Entry
        {
            get
            {
                global::V4l2.AutoGen.V4l2EncIdxEntry[] __value = null;
                if (((__Internal*)__Instance)->entry != null)
                {
                    __value = new global::V4l2.AutoGen.V4l2EncIdxEntry[64];
                    for (int i = 0; i < 64; i++)
                        __value[i] = global::V4l2.AutoGen.V4l2EncIdxEntry.__GetOrCreateInstance((IntPtr)((global::V4l2.AutoGen.V4l2EncIdxEntry.__Internal*)&(((__Internal*)__Instance)->entry[i * sizeof(global::V4l2.AutoGen.V4l2EncIdxEntry.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 64)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 64; i++)
                        *(global::V4l2.AutoGen.V4l2EncIdxEntry.__Internal*) &((__Internal*)__Instance)->entry[i * sizeof(global::V4l2.AutoGen.V4l2EncIdxEntry.__Internal)] = *(global::V4l2.AutoGen.V4l2EncIdxEntry.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class V4l2EncoderCmd : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint cmd;

            [FieldOffset(4)]
            internal uint flags;

            [FieldOffset(8)]
            internal global::V4l2.AutoGen.V4l2EncoderCmd._0.Raw.__Internal raw;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN16v4l2_encoder_cmdC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial struct _0
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2EncoderCmd._0.Raw.__Internal raw;
            }

            public unsafe partial class Raw
            {
                [StructLayout(LayoutKind.Sequential, Size = 32)]
                public partial struct __Internal
                {
                    internal fixed uint data[8];
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EncoderCmd> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EncoderCmd>();

        protected bool __ownsNativeInstance;

        internal static V4l2EncoderCmd __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2EncoderCmd(native.ToPointer(), skipVTables);
        }

        internal static V4l2EncoderCmd __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2EncoderCmd)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2EncoderCmd __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2EncoderCmd(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2EncoderCmd(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2EncoderCmd(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2EncoderCmd()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EncoderCmd.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2EncoderCmd(global::V4l2.AutoGen.V4l2EncoderCmd _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EncoderCmd.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2EncoderCmd.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2EncoderCmd.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Cmd
        {
            get
            {
                return ((__Internal*)__Instance)->cmd;
            }

            set
            {
                ((__Internal*)__Instance)->cmd = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }
    }

    public unsafe partial class V4l2DecoderCmd : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 72)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint cmd;

            [FieldOffset(4)]
            internal uint flags;

            [FieldOffset(8)]
            internal global::V4l2.AutoGen.V4l2DecoderCmd._0.Stop.__Internal stop;

            [FieldOffset(8)]
            internal global::V4l2.AutoGen.V4l2DecoderCmd._0.Start.__Internal start;

            [FieldOffset(8)]
            internal global::V4l2.AutoGen.V4l2DecoderCmd._0.Raw.__Internal raw;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN16v4l2_decoder_cmdC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial struct _0
        {
            [StructLayout(LayoutKind.Explicit, Size = 64)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2DecoderCmd._0.Stop.__Internal stop;

                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2DecoderCmd._0.Start.__Internal start;

                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2DecoderCmd._0.Raw.__Internal raw;
            }

            public unsafe partial class Stop
            {
                [StructLayout(LayoutKind.Sequential, Size = 8)]
                public partial struct __Internal
                {
                    internal ulong pts;
                }
            }

            public unsafe partial class Start
            {
                [StructLayout(LayoutKind.Sequential, Size = 8)]
                public partial struct __Internal
                {
                    internal int speed;
                    internal uint format;
                }
            }

            public unsafe partial class Raw
            {
                [StructLayout(LayoutKind.Sequential, Size = 64)]
                public partial struct __Internal
                {
                    internal fixed uint data[16];
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2DecoderCmd> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2DecoderCmd>();

        protected bool __ownsNativeInstance;

        internal static V4l2DecoderCmd __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2DecoderCmd(native.ToPointer(), skipVTables);
        }

        internal static V4l2DecoderCmd __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2DecoderCmd)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2DecoderCmd __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2DecoderCmd(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2DecoderCmd(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2DecoderCmd(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2DecoderCmd()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2DecoderCmd.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2DecoderCmd(global::V4l2.AutoGen.V4l2DecoderCmd _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2DecoderCmd.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2DecoderCmd.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2DecoderCmd.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Cmd
        {
            get
            {
                return ((__Internal*)__Instance)->cmd;
            }

            set
            {
                ((__Internal*)__Instance)->cmd = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }
    }

    public unsafe partial class V4l2VbiFormat : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 44)]
        public partial struct __Internal
        {
            internal uint sampling_rate;
            internal uint offset;
            internal uint samples_per_line;
            internal uint sample_format;
            internal fixed int start[2];
            internal fixed uint count[2];
            internal uint flags;
            internal fixed uint reserved[2];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN15v4l2_vbi_formatC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2VbiFormat> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2VbiFormat>();

        protected bool __ownsNativeInstance;

        internal static V4l2VbiFormat __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2VbiFormat(native.ToPointer(), skipVTables);
        }

        internal static V4l2VbiFormat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2VbiFormat)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2VbiFormat __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2VbiFormat(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2VbiFormat(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2VbiFormat(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2VbiFormat()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2VbiFormat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2VbiFormat(global::V4l2.AutoGen.V4l2VbiFormat _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2VbiFormat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2VbiFormat.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2VbiFormat.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint SamplingRate
        {
            get
            {
                return ((__Internal*)__Instance)->sampling_rate;
            }

            set
            {
                ((__Internal*)__Instance)->sampling_rate = value;
            }
        }

        public uint Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }

        public uint SamplesPerLine
        {
            get
            {
                return ((__Internal*)__Instance)->samples_per_line;
            }

            set
            {
                ((__Internal*)__Instance)->samples_per_line = value;
            }
        }

        public uint SampleFormat
        {
            get
            {
                return ((__Internal*)__Instance)->sample_format;
            }

            set
            {
                ((__Internal*)__Instance)->sample_format = value;
            }
        }

        public int[] Start
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->start, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->start[i] = value[i];
                }
            }
        }

        public uint[] Count
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->count, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->count[i] = value[i];
                }
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2SlicedVbiFormat : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 112)]
        public partial struct __Internal
        {
            internal ushort service_set;
            internal fixed ushort service_lines[48];
            internal uint io_size;
            internal fixed uint reserved[2];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN22v4l2_sliced_vbi_formatC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2SlicedVbiFormat> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2SlicedVbiFormat>();

        protected bool __ownsNativeInstance;

        internal static V4l2SlicedVbiFormat __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2SlicedVbiFormat(native.ToPointer(), skipVTables);
        }

        internal static V4l2SlicedVbiFormat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2SlicedVbiFormat)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2SlicedVbiFormat __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2SlicedVbiFormat(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2SlicedVbiFormat(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2SlicedVbiFormat(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2SlicedVbiFormat()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2SlicedVbiFormat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2SlicedVbiFormat(global::V4l2.AutoGen.V4l2SlicedVbiFormat _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2SlicedVbiFormat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2SlicedVbiFormat.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2SlicedVbiFormat.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort ServiceSet
        {
            get
            {
                return ((__Internal*)__Instance)->service_set;
            }

            set
            {
                ((__Internal*)__Instance)->service_set = value;
            }
        }

        public uint IoSize
        {
            get
            {
                return ((__Internal*)__Instance)->io_size;
            }

            set
            {
                ((__Internal*)__Instance)->io_size = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2SlicedVbiCap : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 116)]
        public partial struct __Internal
        {
            internal ushort service_set;
            internal fixed ushort service_lines[48];
            internal uint type;
            internal fixed uint reserved[3];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN19v4l2_sliced_vbi_capC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2SlicedVbiCap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2SlicedVbiCap>();

        protected bool __ownsNativeInstance;

        internal static V4l2SlicedVbiCap __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2SlicedVbiCap(native.ToPointer(), skipVTables);
        }

        internal static V4l2SlicedVbiCap __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2SlicedVbiCap)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2SlicedVbiCap __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2SlicedVbiCap(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2SlicedVbiCap(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2SlicedVbiCap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2SlicedVbiCap()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2SlicedVbiCap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2SlicedVbiCap(global::V4l2.AutoGen.V4l2SlicedVbiCap _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2SlicedVbiCap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2SlicedVbiCap.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2SlicedVbiCap.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort ServiceSet
        {
            get
            {
                return ((__Internal*)__Instance)->service_set;
            }

            set
            {
                ((__Internal*)__Instance)->service_set = value;
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2SlicedVbiData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal uint id;
            internal uint field;
            internal uint line;
            internal uint reserved;
            internal fixed byte data[48];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN20v4l2_sliced_vbi_dataC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2SlicedVbiData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2SlicedVbiData>();

        protected bool __ownsNativeInstance;

        internal static V4l2SlicedVbiData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2SlicedVbiData(native.ToPointer(), skipVTables);
        }

        internal static V4l2SlicedVbiData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2SlicedVbiData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2SlicedVbiData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2SlicedVbiData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2SlicedVbiData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2SlicedVbiData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2SlicedVbiData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2SlicedVbiData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2SlicedVbiData(global::V4l2.AutoGen.V4l2SlicedVbiData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2SlicedVbiData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2SlicedVbiData.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2SlicedVbiData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        public uint Field
        {
            get
            {
                return ((__Internal*)__Instance)->field;
            }

            set
            {
                ((__Internal*)__Instance)->field = value;
            }
        }

        public uint Line
        {
            get
            {
                return ((__Internal*)__Instance)->line;
            }

            set
            {
                ((__Internal*)__Instance)->line = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        public byte[] Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->data, 48);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 48; i++)
                        ((__Internal*)__Instance)->data[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2MpegVbiItv0Line : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 43)]
        public partial struct __Internal
        {
            internal byte id;
            internal fixed byte data[42];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN23v4l2_mpeg_vbi_itv0_lineC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2MpegVbiItv0Line> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2MpegVbiItv0Line>();

        protected bool __ownsNativeInstance;

        internal static V4l2MpegVbiItv0Line __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2MpegVbiItv0Line(native.ToPointer(), skipVTables);
        }

        internal static V4l2MpegVbiItv0Line __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2MpegVbiItv0Line)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2MpegVbiItv0Line __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2MpegVbiItv0Line(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2MpegVbiItv0Line(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2MpegVbiItv0Line(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2MpegVbiItv0Line()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2MpegVbiItv0Line(global::V4l2.AutoGen.V4l2MpegVbiItv0Line _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        public byte[] Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->data, 42);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 42; i++)
                        ((__Internal*)__Instance)->data[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2MpegVbiItv0 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1513)]
        public partial struct __Internal
        {
            internal fixed uint linemask[2];
            internal fixed byte line[1505];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN18v4l2_mpeg_vbi_itv0C2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2MpegVbiItv0> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2MpegVbiItv0>();

        protected bool __ownsNativeInstance;

        internal static V4l2MpegVbiItv0 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2MpegVbiItv0(native.ToPointer(), skipVTables);
        }

        internal static V4l2MpegVbiItv0 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2MpegVbiItv0)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2MpegVbiItv0 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2MpegVbiItv0(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2MpegVbiItv0(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2MpegVbiItv0(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2MpegVbiItv0()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2MpegVbiItv0.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2MpegVbiItv0(global::V4l2.AutoGen.V4l2MpegVbiItv0 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2MpegVbiItv0.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2MpegVbiItv0.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2MpegVbiItv0.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint[] Linemask
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->linemask, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->linemask[i] = value[i];
                }
            }
        }

        public global::V4l2.AutoGen.V4l2MpegVbiItv0Line[] Line
        {
            get
            {
                global::V4l2.AutoGen.V4l2MpegVbiItv0Line[] __value = null;
                if (((__Internal*)__Instance)->line != null)
                {
                    __value = new global::V4l2.AutoGen.V4l2MpegVbiItv0Line[35];
                    for (int i = 0; i < 35; i++)
                        __value[i] = global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__GetOrCreateInstance((IntPtr)((global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__Internal*)&(((__Internal*)__Instance)->line[i * sizeof(global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 35)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 35; i++)
                        *(global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__Internal*) &((__Internal*)__Instance)->line[i * sizeof(global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__Internal)] = *(global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class V4l2MpegVbiITV0 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1548)]
        public partial struct __Internal
        {
            internal fixed byte line[1548];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN18v4l2_mpeg_vbi_ITV0C2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2MpegVbiITV0> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2MpegVbiITV0>();

        protected bool __ownsNativeInstance;

        internal static V4l2MpegVbiITV0 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2MpegVbiITV0(native.ToPointer(), skipVTables);
        }

        internal static V4l2MpegVbiITV0 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2MpegVbiITV0)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2MpegVbiITV0 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2MpegVbiITV0(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2MpegVbiITV0(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2MpegVbiITV0(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2MpegVbiITV0()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2MpegVbiITV0.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2MpegVbiITV0(global::V4l2.AutoGen.V4l2MpegVbiITV0 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2MpegVbiITV0.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2MpegVbiITV0.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2MpegVbiITV0.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::V4l2.AutoGen.V4l2MpegVbiItv0Line[] Line
        {
            get
            {
                global::V4l2.AutoGen.V4l2MpegVbiItv0Line[] __value = null;
                if (((__Internal*)__Instance)->line != null)
                {
                    __value = new global::V4l2.AutoGen.V4l2MpegVbiItv0Line[36];
                    for (int i = 0; i < 36; i++)
                        __value[i] = global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__GetOrCreateInstance((IntPtr)((global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__Internal*)&(((__Internal*)__Instance)->line[i * sizeof(global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 36)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 36; i++)
                        *(global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__Internal*) &((__Internal*)__Instance)->line[i * sizeof(global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__Internal)] = *(global::V4l2.AutoGen.V4l2MpegVbiItv0Line.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class V4l2MpegVbiFmtIvtv : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1552)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed byte magic[4];

            [FieldOffset(4)]
            internal global::V4l2.AutoGen.V4l2MpegVbiItv0.__Internal itv0;

            [FieldOffset(4)]
            internal global::V4l2.AutoGen.V4l2MpegVbiITV0.__Internal ITV0;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN22v4l2_mpeg_vbi_fmt_ivtvC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2MpegVbiFmtIvtv> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2MpegVbiFmtIvtv>();

        protected bool __ownsNativeInstance;

        internal static V4l2MpegVbiFmtIvtv __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2MpegVbiFmtIvtv(native.ToPointer(), skipVTables);
        }

        internal static V4l2MpegVbiFmtIvtv __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2MpegVbiFmtIvtv)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2MpegVbiFmtIvtv __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2MpegVbiFmtIvtv(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2MpegVbiFmtIvtv(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2MpegVbiFmtIvtv(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2MpegVbiFmtIvtv()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2MpegVbiFmtIvtv.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2MpegVbiFmtIvtv(global::V4l2.AutoGen.V4l2MpegVbiFmtIvtv _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2MpegVbiFmtIvtv.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2MpegVbiFmtIvtv.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2MpegVbiFmtIvtv.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte[] Magic
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->magic, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->magic[i] = value[i];
                }
            }
        }

        public global::V4l2.AutoGen.V4l2MpegVbiItv0 Itv0
        {
            get
            {
                return global::V4l2.AutoGen.V4l2MpegVbiItv0.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->itv0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->itv0 = *(global::V4l2.AutoGen.V4l2MpegVbiItv0.__Internal*) value.__Instance;
            }
        }

        public global::V4l2.AutoGen.V4l2MpegVbiITV0 ITV0
        {
            get
            {
                return global::V4l2.AutoGen.V4l2MpegVbiITV0.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ITV0));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ITV0 = *(global::V4l2.AutoGen.V4l2MpegVbiITV0.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>
    /// <para>struct v4l2_plane_pix_format - additional, per-plane format definition</para>
    /// <para>maximum size in bytes required for data, for which</para>
    /// <para>this plane will be used</para>
    /// <para>distance in bytes between the leftmost pixels in two</para>
    /// <para>adjacent lines</para>
    /// <para>drivers and applications must zero this array</para>
    /// </summary>
    public unsafe partial class V4l2PlanePixFormat : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            internal uint sizeimage;
            internal uint bytesperline;
            internal fixed ushort reserved[6];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN21v4l2_plane_pix_formatC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2PlanePixFormat> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2PlanePixFormat>();

        protected bool __ownsNativeInstance;

        internal static V4l2PlanePixFormat __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2PlanePixFormat(native.ToPointer(), skipVTables);
        }

        internal static V4l2PlanePixFormat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2PlanePixFormat)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2PlanePixFormat __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2PlanePixFormat(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2PlanePixFormat(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2PlanePixFormat(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2PlanePixFormat()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2PlanePixFormat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2PlanePixFormat(global::V4l2.AutoGen.V4l2PlanePixFormat _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2PlanePixFormat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2PlanePixFormat.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2PlanePixFormat.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Sizeimage
        {
            get
            {
                return ((__Internal*)__Instance)->sizeimage;
            }

            set
            {
                ((__Internal*)__Instance)->sizeimage = value;
            }
        }

        public uint Bytesperline
        {
            get
            {
                return ((__Internal*)__Instance)->bytesperline;
            }

            set
            {
                ((__Internal*)__Instance)->bytesperline = value;
            }
        }

        public ushort[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->reserved, 6);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 6; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    /// <summary>
    /// <para>struct v4l2_pix_format_mplane - multiplanar format definition</para>
    /// <para>image width in pixels</para>
    /// <para>image height in pixels</para>
    /// <para>little endian four character code (fourcc)</para>
    /// <para>enum v4l2_field; field order (for interlaced video)</para>
    /// <para>enum v4l2_colorspace; supplemental to pixelformat</para>
    /// <para>per-plane information</para>
    /// </summary>
    /// <remarks>
    /// <para>format flags (V4L2_PIX_FMT_FLAG_*)</para>
    /// <para>enum v4l2_ycbcr_encoding, Y'CbCr encoding</para>
    /// <para>enum v4l2_hsv_encoding, HSV encoding</para>
    /// <para>enum v4l2_quantization, colorspace quantization</para>
    /// <para>enum v4l2_xfer_func, colorspace transfer function</para>
    /// <para>drivers and applications must zero this array</para>
    /// </remarks>
    public unsafe partial class V4l2PixFormatMplane : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 192)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint width;

            [FieldOffset(4)]
            internal uint height;

            [FieldOffset(8)]
            internal uint pixelformat;

            [FieldOffset(12)]
            internal uint field;

            [FieldOffset(16)]
            internal uint colorspace;

            [FieldOffset(20)]
            internal fixed byte plane_fmt[160];

            [FieldOffset(180)]
            internal byte num_planes;

            [FieldOffset(181)]
            internal byte flags;

            [FieldOffset(182)]
            internal byte ycbcr_enc;

            [FieldOffset(182)]
            internal byte hsv_enc;

            [FieldOffset(183)]
            internal byte quantization;

            [FieldOffset(184)]
            internal byte xfer_func;

            [FieldOffset(185)]
            internal fixed byte reserved[7];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN22v4l2_pix_format_mplaneC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2PixFormatMplane> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2PixFormatMplane>();

        protected bool __ownsNativeInstance;

        internal static V4l2PixFormatMplane __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2PixFormatMplane(native.ToPointer(), skipVTables);
        }

        internal static V4l2PixFormatMplane __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2PixFormatMplane)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2PixFormatMplane __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2PixFormatMplane(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2PixFormatMplane(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2PixFormatMplane(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2PixFormatMplane()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2PixFormatMplane.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2PixFormatMplane(global::V4l2.AutoGen.V4l2PixFormatMplane _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2PixFormatMplane.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2PixFormatMplane.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2PixFormatMplane.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public uint Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        public uint Pixelformat
        {
            get
            {
                return ((__Internal*)__Instance)->pixelformat;
            }

            set
            {
                ((__Internal*)__Instance)->pixelformat = value;
            }
        }

        public uint Field
        {
            get
            {
                return ((__Internal*)__Instance)->field;
            }

            set
            {
                ((__Internal*)__Instance)->field = value;
            }
        }

        public uint Colorspace
        {
            get
            {
                return ((__Internal*)__Instance)->colorspace;
            }

            set
            {
                ((__Internal*)__Instance)->colorspace = value;
            }
        }

        public global::V4l2.AutoGen.V4l2PlanePixFormat[] PlaneFmt
        {
            get
            {
                global::V4l2.AutoGen.V4l2PlanePixFormat[] __value = null;
                if (((__Internal*)__Instance)->plane_fmt != null)
                {
                    __value = new global::V4l2.AutoGen.V4l2PlanePixFormat[8];
                    for (int i = 0; i < 8; i++)
                        __value[i] = global::V4l2.AutoGen.V4l2PlanePixFormat.__GetOrCreateInstance((IntPtr)((global::V4l2.AutoGen.V4l2PlanePixFormat.__Internal*)&(((__Internal*)__Instance)->plane_fmt[i * sizeof(global::V4l2.AutoGen.V4l2PlanePixFormat.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 8)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 8; i++)
                        *(global::V4l2.AutoGen.V4l2PlanePixFormat.__Internal*) &((__Internal*)__Instance)->plane_fmt[i * sizeof(global::V4l2.AutoGen.V4l2PlanePixFormat.__Internal)] = *(global::V4l2.AutoGen.V4l2PlanePixFormat.__Internal*)value[i].__Instance;
                }
            }
        }

        public byte NumPlanes
        {
            get
            {
                return ((__Internal*)__Instance)->num_planes;
            }

            set
            {
                ((__Internal*)__Instance)->num_planes = value;
            }
        }

        public byte Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public byte YcbcrEnc
        {
            get
            {
                return ((__Internal*)__Instance)->ycbcr_enc;
            }

            set
            {
                ((__Internal*)__Instance)->ycbcr_enc = value;
            }
        }

        public byte HsvEnc
        {
            get
            {
                return ((__Internal*)__Instance)->hsv_enc;
            }

            set
            {
                ((__Internal*)__Instance)->hsv_enc = value;
            }
        }

        public byte Quantization
        {
            get
            {
                return ((__Internal*)__Instance)->quantization;
            }

            set
            {
                ((__Internal*)__Instance)->quantization = value;
            }
        }

        public byte XferFunc
        {
            get
            {
                return ((__Internal*)__Instance)->xfer_func;
            }

            set
            {
                ((__Internal*)__Instance)->xfer_func = value;
            }
        }

        public byte[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->reserved, 7);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 7; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    /// <summary>
    /// <para>struct v4l2_sdr_format - SDR format definition</para>
    /// <para>little endian four character code (fourcc)</para>
    /// <para>maximum size in bytes required for data</para>
    /// <para>drivers and applications must zero this array</para>
    /// </summary>
    public unsafe partial class V4l2SdrFormat : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal uint pixelformat;
            internal uint buffersize;
            internal fixed byte reserved[24];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN15v4l2_sdr_formatC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2SdrFormat> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2SdrFormat>();

        protected bool __ownsNativeInstance;

        internal static V4l2SdrFormat __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2SdrFormat(native.ToPointer(), skipVTables);
        }

        internal static V4l2SdrFormat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2SdrFormat)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2SdrFormat __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2SdrFormat(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2SdrFormat(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2SdrFormat(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2SdrFormat()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2SdrFormat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2SdrFormat(global::V4l2.AutoGen.V4l2SdrFormat _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2SdrFormat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2SdrFormat.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2SdrFormat.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Pixelformat
        {
            get
            {
                return ((__Internal*)__Instance)->pixelformat;
            }

            set
            {
                ((__Internal*)__Instance)->pixelformat = value;
            }
        }

        public uint Buffersize
        {
            get
            {
                return ((__Internal*)__Instance)->buffersize;
            }

            set
            {
                ((__Internal*)__Instance)->buffersize = value;
            }
        }

        public byte[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->reserved, 24);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 24; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    /// <summary>
    /// <para>struct v4l2_meta_format - metadata format definition</para>
    /// <para>little endian four character code (fourcc)</para>
    /// <para>maximum size in bytes required for data</para>
    /// </summary>
    public unsafe partial class V4l2MetaFormat : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal uint dataformat;
            internal uint buffersize;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN16v4l2_meta_formatC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2MetaFormat> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2MetaFormat>();

        protected bool __ownsNativeInstance;

        internal static V4l2MetaFormat __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2MetaFormat(native.ToPointer(), skipVTables);
        }

        internal static V4l2MetaFormat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2MetaFormat)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2MetaFormat __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2MetaFormat(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2MetaFormat(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2MetaFormat(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2MetaFormat()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2MetaFormat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2MetaFormat(global::V4l2.AutoGen.V4l2MetaFormat _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2MetaFormat.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2MetaFormat.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2MetaFormat.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Dataformat
        {
            get
            {
                return ((__Internal*)__Instance)->dataformat;
            }

            set
            {
                ((__Internal*)__Instance)->dataformat = value;
            }
        }

        public uint Buffersize
        {
            get
            {
                return ((__Internal*)__Instance)->buffersize;
            }

            set
            {
                ((__Internal*)__Instance)->buffersize = value;
            }
        }
    }

    /// <summary>
    /// <para>struct v4l2_format - stream data format</para>
    /// <para>enum v4l2_buf_type; type of the data stream</para>
    /// <para>definition of an image format</para>
    /// <para>definition of a multiplanar image format</para>
    /// <para>definition of an overlaid image</para>
    /// <para>raw VBI capture or output parameters</para>
    /// <para>sliced VBI capture or output parameters</para>
    /// <para>placeholder for future extensions and custom formats</para>
    /// <para>union of</para>
    /// <para>and</para>
    /// </summary>
    public unsafe partial class V4l2Format : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 208)]
        public partial struct __Internal
        {
            internal uint type;
            internal global::V4l2.AutoGen.V4l2Format.Fmt.__Internal fmt;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN11v4l2_formatC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial struct Fmt
        {
            [StructLayout(LayoutKind.Explicit, Size = 200)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2PixFormat.__Internal pix;

                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2PixFormatMplane.__Internal pix_mp;

                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2Window.__Internal win;

                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2VbiFormat.__Internal vbi;

                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2SlicedVbiFormat.__Internal sliced;

                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2SdrFormat.__Internal sdr;

                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2MetaFormat.__Internal meta;

                [FieldOffset(0)]
                internal fixed byte raw_data[200];

                [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN11v4l2_formatUt_C2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Fmt.__Internal __instance;
            internal Fmt.__Internal __Instance { get { return __instance; } }

            internal static Fmt __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Fmt(native.ToPointer(), skipVTables);
            }

            internal static Fmt __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Fmt(native, skipVTables);
            }

            private Fmt(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Fmt(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::V4l2.AutoGen.V4l2Format.Fmt.__Internal*) native;
            }

            public Fmt(global::V4l2.AutoGen.V4l2Format.Fmt __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            public global::V4l2.AutoGen.V4l2PixFormat Pix
            {
                get
                {
                    return global::V4l2.AutoGen.V4l2PixFormat.__CreateInstance(__instance.pix);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.pix = *(global::V4l2.AutoGen.V4l2PixFormat.__Internal*) value.__Instance;
                }
            }

            public global::V4l2.AutoGen.V4l2PixFormatMplane PixMp
            {
                get
                {
                    return global::V4l2.AutoGen.V4l2PixFormatMplane.__CreateInstance(__instance.pix_mp);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.pix_mp = *(global::V4l2.AutoGen.V4l2PixFormatMplane.__Internal*) value.__Instance;
                }
            }

            public global::V4l2.AutoGen.V4l2Window Win
            {
                get
                {
                    return global::V4l2.AutoGen.V4l2Window.__CreateInstance(__instance.win);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.win = *(global::V4l2.AutoGen.V4l2Window.__Internal*) value.__Instance;
                }
            }

            public global::V4l2.AutoGen.V4l2VbiFormat Vbi
            {
                get
                {
                    return global::V4l2.AutoGen.V4l2VbiFormat.__CreateInstance(__instance.vbi);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.vbi = *(global::V4l2.AutoGen.V4l2VbiFormat.__Internal*) value.__Instance;
                }
            }

            public global::V4l2.AutoGen.V4l2SlicedVbiFormat Sliced
            {
                get
                {
                    return global::V4l2.AutoGen.V4l2SlicedVbiFormat.__CreateInstance(__instance.sliced);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.sliced = *(global::V4l2.AutoGen.V4l2SlicedVbiFormat.__Internal*) value.__Instance;
                }
            }

            public global::V4l2.AutoGen.V4l2SdrFormat Sdr
            {
                get
                {
                    return global::V4l2.AutoGen.V4l2SdrFormat.__CreateInstance(__instance.sdr);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.sdr = *(global::V4l2.AutoGen.V4l2SdrFormat.__Internal*) value.__Instance;
                }
            }

            public global::V4l2.AutoGen.V4l2MetaFormat Meta
            {
                get
                {
                    return global::V4l2.AutoGen.V4l2MetaFormat.__CreateInstance(__instance.meta);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.meta = *(global::V4l2.AutoGen.V4l2MetaFormat.__Internal*) value.__Instance;
                }
            }

            public byte[] RawData
            {
                get
                {
                    fixed (byte* __arrPtr = __instance.raw_data)
                    {
                        return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 200);
                    }
                }

                set
                {
                    fixed (byte* __arrPtr = __instance.raw_data)
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 200; i++)
                                __arrPtr[i] = value[i];
                        }
                    }
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Format> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Format>();

        protected bool __ownsNativeInstance;

        internal static V4l2Format __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Format(native.ToPointer(), skipVTables);
        }

        internal static V4l2Format __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Format)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Format __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Format(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Format(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Format(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Format()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Format.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Format(global::V4l2.AutoGen.V4l2Format _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Format.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Format.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Format.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public global::V4l2.AutoGen.V4l2Format.Fmt fmt
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Format.Fmt.__CreateInstance(((__Internal*)__Instance)->fmt);
            }

            set
            {
                ((__Internal*)__Instance)->fmt = value.__Instance;
            }
        }
    }

    public unsafe partial class V4l2Streamparm : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 204)]
        public partial struct __Internal
        {
            internal uint type;
            internal global::V4l2.AutoGen.V4l2Streamparm.Parm.__Internal parm;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN15v4l2_streamparmC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial struct Parm
        {
            [StructLayout(LayoutKind.Explicit, Size = 200)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2Captureparm.__Internal capture;

                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2Outputparm.__Internal output;

                [FieldOffset(0)]
                internal fixed byte raw_data[200];

                [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN15v4l2_streamparmUt_C2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
            }

            private Parm.__Internal __instance;
            internal Parm.__Internal __Instance { get { return __instance; } }

            internal static Parm __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Parm(native.ToPointer(), skipVTables);
            }

            internal static Parm __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Parm(native, skipVTables);
            }

            private Parm(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Parm(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::V4l2.AutoGen.V4l2Streamparm.Parm.__Internal*) native;
            }

            public Parm(global::V4l2.AutoGen.V4l2Streamparm.Parm __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            public global::V4l2.AutoGen.V4l2Captureparm Capture
            {
                get
                {
                    return global::V4l2.AutoGen.V4l2Captureparm.__CreateInstance(__instance.capture);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.capture = *(global::V4l2.AutoGen.V4l2Captureparm.__Internal*) value.__Instance;
                }
            }

            public global::V4l2.AutoGen.V4l2Outputparm Output
            {
                get
                {
                    return global::V4l2.AutoGen.V4l2Outputparm.__CreateInstance(__instance.output);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.output = *(global::V4l2.AutoGen.V4l2Outputparm.__Internal*) value.__Instance;
                }
            }

            public byte[] RawData
            {
                get
                {
                    fixed (byte* __arrPtr = __instance.raw_data)
                    {
                        return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 200);
                    }
                }

                set
                {
                    fixed (byte* __arrPtr = __instance.raw_data)
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 200; i++)
                                __arrPtr[i] = value[i];
                        }
                    }
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Streamparm> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Streamparm>();

        protected bool __ownsNativeInstance;

        internal static V4l2Streamparm __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Streamparm(native.ToPointer(), skipVTables);
        }

        internal static V4l2Streamparm __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Streamparm)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Streamparm __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Streamparm(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Streamparm(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Streamparm(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Streamparm()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Streamparm.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Streamparm(global::V4l2.AutoGen.V4l2Streamparm _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Streamparm.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Streamparm.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Streamparm.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public global::V4l2.AutoGen.V4l2Streamparm.Parm parm
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Streamparm.Parm.__CreateInstance(((__Internal*)__Instance)->parm);
            }

            set
            {
                ((__Internal*)__Instance)->parm = value.__Instance;
            }
        }
    }

    public unsafe partial class V4l2EventVsync : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal byte field;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN16v4l2_event_vsyncC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EventVsync> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EventVsync>();

        protected bool __ownsNativeInstance;

        internal static V4l2EventVsync __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2EventVsync(native.ToPointer(), skipVTables);
        }

        internal static V4l2EventVsync __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2EventVsync)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2EventVsync __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2EventVsync(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2EventVsync(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2EventVsync(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2EventVsync()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EventVsync.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2EventVsync(global::V4l2.AutoGen.V4l2EventVsync _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EventVsync.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2EventVsync.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2EventVsync.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte Field
        {
            get
            {
                return ((__Internal*)__Instance)->field;
            }

            set
            {
                ((__Internal*)__Instance)->field = value;
            }
        }
    }

    public unsafe partial class V4l2EventCtrl : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint changes;

            [FieldOffset(4)]
            internal uint type;

            [FieldOffset(8)]
            internal int value;

            [FieldOffset(8)]
            internal long value64;

            [FieldOffset(16)]
            internal uint flags;

            [FieldOffset(20)]
            internal int minimum;

            [FieldOffset(24)]
            internal int maximum;

            [FieldOffset(28)]
            internal int step;

            [FieldOffset(32)]
            internal int default_value;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN15v4l2_event_ctrlC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EventCtrl> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EventCtrl>();

        protected bool __ownsNativeInstance;

        internal static V4l2EventCtrl __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2EventCtrl(native.ToPointer(), skipVTables);
        }

        internal static V4l2EventCtrl __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2EventCtrl)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2EventCtrl __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2EventCtrl(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2EventCtrl(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2EventCtrl(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2EventCtrl()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EventCtrl.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2EventCtrl(global::V4l2.AutoGen.V4l2EventCtrl _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EventCtrl.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2EventCtrl.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2EventCtrl.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Changes
        {
            get
            {
                return ((__Internal*)__Instance)->changes;
            }

            set
            {
                ((__Internal*)__Instance)->changes = value;
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public int Value
        {
            get
            {
                return ((__Internal*)__Instance)->value;
            }

            set
            {
                ((__Internal*)__Instance)->value = value;
            }
        }

        public long Value64
        {
            get
            {
                return ((__Internal*)__Instance)->value64;
            }

            set
            {
                ((__Internal*)__Instance)->value64 = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public int Minimum
        {
            get
            {
                return ((__Internal*)__Instance)->minimum;
            }

            set
            {
                ((__Internal*)__Instance)->minimum = value;
            }
        }

        public int Maximum
        {
            get
            {
                return ((__Internal*)__Instance)->maximum;
            }

            set
            {
                ((__Internal*)__Instance)->maximum = value;
            }
        }

        public int Step
        {
            get
            {
                return ((__Internal*)__Instance)->step;
            }

            set
            {
                ((__Internal*)__Instance)->step = value;
            }
        }

        public int DefaultValue
        {
            get
            {
                return ((__Internal*)__Instance)->default_value;
            }

            set
            {
                ((__Internal*)__Instance)->default_value = value;
            }
        }
    }

    public unsafe partial class V4l2EventFrameSync : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal uint frame_sequence;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN21v4l2_event_frame_syncC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EventFrameSync> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EventFrameSync>();

        protected bool __ownsNativeInstance;

        internal static V4l2EventFrameSync __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2EventFrameSync(native.ToPointer(), skipVTables);
        }

        internal static V4l2EventFrameSync __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2EventFrameSync)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2EventFrameSync __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2EventFrameSync(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2EventFrameSync(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2EventFrameSync(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2EventFrameSync()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EventFrameSync.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2EventFrameSync(global::V4l2.AutoGen.V4l2EventFrameSync _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EventFrameSync.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2EventFrameSync.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2EventFrameSync.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint FrameSequence
        {
            get
            {
                return ((__Internal*)__Instance)->frame_sequence;
            }

            set
            {
                ((__Internal*)__Instance)->frame_sequence = value;
            }
        }
    }

    public unsafe partial class V4l2EventSrcChange : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal uint changes;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN21v4l2_event_src_changeC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EventSrcChange> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EventSrcChange>();

        protected bool __ownsNativeInstance;

        internal static V4l2EventSrcChange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2EventSrcChange(native.ToPointer(), skipVTables);
        }

        internal static V4l2EventSrcChange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2EventSrcChange)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2EventSrcChange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2EventSrcChange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2EventSrcChange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2EventSrcChange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2EventSrcChange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EventSrcChange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2EventSrcChange(global::V4l2.AutoGen.V4l2EventSrcChange _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EventSrcChange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2EventSrcChange.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2EventSrcChange.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Changes
        {
            get
            {
                return ((__Internal*)__Instance)->changes;
            }

            set
            {
                ((__Internal*)__Instance)->changes = value;
            }
        }
    }

    /// <summary>
    /// <para>struct v4l2_event_motion_det - motion detection event</para>
    /// <para>if V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ is set, then the</para>
    /// <para>frame_sequence field is valid.</para>
    /// <para>the frame sequence number associated with this event.</para>
    /// <para>which regions detected motion.</para>
    /// </summary>
    public unsafe partial class V4l2EventMotionDet : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal uint flags;
            internal uint frame_sequence;
            internal uint region_mask;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN21v4l2_event_motion_detC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EventMotionDet> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EventMotionDet>();

        protected bool __ownsNativeInstance;

        internal static V4l2EventMotionDet __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2EventMotionDet(native.ToPointer(), skipVTables);
        }

        internal static V4l2EventMotionDet __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2EventMotionDet)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2EventMotionDet __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2EventMotionDet(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2EventMotionDet(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2EventMotionDet(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2EventMotionDet()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EventMotionDet.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2EventMotionDet(global::V4l2.AutoGen.V4l2EventMotionDet _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EventMotionDet.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2EventMotionDet.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2EventMotionDet.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public uint FrameSequence
        {
            get
            {
                return ((__Internal*)__Instance)->frame_sequence;
            }

            set
            {
                ((__Internal*)__Instance)->frame_sequence = value;
            }
        }

        public uint RegionMask
        {
            get
            {
                return ((__Internal*)__Instance)->region_mask;
            }

            set
            {
                ((__Internal*)__Instance)->region_mask = value;
            }
        }
    }

    public unsafe partial class V4l2Event : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 136)]
        public partial struct __Internal
        {
            internal uint type;
            internal global::V4l2.AutoGen.V4l2Event.U.__Internal u;
            internal uint pending;
            internal uint sequence;
            internal global::Timespec.__Internal timestamp;
            internal uint id;
            internal fixed uint reserved[8];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN10v4l2_eventC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial struct U
        {
            [StructLayout(LayoutKind.Explicit, Size = 64)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2EventVsync.__Internal vsync;

                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2EventCtrl.__Internal ctrl;

                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2EventFrameSync.__Internal frame_sync;

                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2EventSrcChange.__Internal src_change;

                [FieldOffset(0)]
                internal global::V4l2.AutoGen.V4l2EventMotionDet.__Internal motion_det;

                [FieldOffset(0)]
                internal fixed byte data[64];

                [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN10v4l2_eventUt_C2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
            }

            private U.__Internal __instance;
            internal U.__Internal __Instance { get { return __instance; } }

            internal static U __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new U(native.ToPointer(), skipVTables);
            }

            internal static U __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new U(native, skipVTables);
            }

            private U(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private U(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::V4l2.AutoGen.V4l2Event.U.__Internal*) native;
            }

            public U(global::V4l2.AutoGen.V4l2Event.U __0)
                : this()
            {
                var ____arg0 = __0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            public global::V4l2.AutoGen.V4l2EventVsync Vsync
            {
                get
                {
                    return global::V4l2.AutoGen.V4l2EventVsync.__CreateInstance(__instance.vsync);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.vsync = *(global::V4l2.AutoGen.V4l2EventVsync.__Internal*) value.__Instance;
                }
            }

            public global::V4l2.AutoGen.V4l2EventCtrl Ctrl
            {
                get
                {
                    return global::V4l2.AutoGen.V4l2EventCtrl.__CreateInstance(__instance.ctrl);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.ctrl = *(global::V4l2.AutoGen.V4l2EventCtrl.__Internal*) value.__Instance;
                }
            }

            public global::V4l2.AutoGen.V4l2EventFrameSync FrameSync
            {
                get
                {
                    return global::V4l2.AutoGen.V4l2EventFrameSync.__CreateInstance(__instance.frame_sync);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.frame_sync = *(global::V4l2.AutoGen.V4l2EventFrameSync.__Internal*) value.__Instance;
                }
            }

            public global::V4l2.AutoGen.V4l2EventSrcChange SrcChange
            {
                get
                {
                    return global::V4l2.AutoGen.V4l2EventSrcChange.__CreateInstance(__instance.src_change);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.src_change = *(global::V4l2.AutoGen.V4l2EventSrcChange.__Internal*) value.__Instance;
                }
            }

            public global::V4l2.AutoGen.V4l2EventMotionDet MotionDet
            {
                get
                {
                    return global::V4l2.AutoGen.V4l2EventMotionDet.__CreateInstance(__instance.motion_det);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.motion_det = *(global::V4l2.AutoGen.V4l2EventMotionDet.__Internal*) value.__Instance;
                }
            }

            public byte[] Data
            {
                get
                {
                    fixed (byte* __arrPtr = __instance.data)
                    {
                        return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 64);
                    }
                }

                set
                {
                    fixed (byte* __arrPtr = __instance.data)
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 64; i++)
                                __arrPtr[i] = value[i];
                        }
                    }
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Event> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2Event>();

        protected bool __ownsNativeInstance;

        internal static V4l2Event __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2Event(native.ToPointer(), skipVTables);
        }

        internal static V4l2Event __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2Event)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2Event __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2Event(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2Event(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2Event(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2Event()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Event.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2Event(global::V4l2.AutoGen.V4l2Event _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2Event.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2Event.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2Event.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public global::V4l2.AutoGen.V4l2Event.U u
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Event.U.__CreateInstance(((__Internal*)__Instance)->u);
            }

            set
            {
                ((__Internal*)__Instance)->u = value.__Instance;
            }
        }

        public uint Pending
        {
            get
            {
                return ((__Internal*)__Instance)->pending;
            }

            set
            {
                ((__Internal*)__Instance)->pending = value;
            }
        }

        public uint Sequence
        {
            get
            {
                return ((__Internal*)__Instance)->sequence;
            }

            set
            {
                ((__Internal*)__Instance)->sequence = value;
            }
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2EventSubscription : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal uint type;
            internal uint id;
            internal uint flags;
            internal fixed uint reserved[5];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN23v4l2_event_subscriptionC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EventSubscription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2EventSubscription>();

        protected bool __ownsNativeInstance;

        internal static V4l2EventSubscription __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2EventSubscription(native.ToPointer(), skipVTables);
        }

        internal static V4l2EventSubscription __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2EventSubscription)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2EventSubscription __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2EventSubscription(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2EventSubscription(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2EventSubscription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2EventSubscription()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EventSubscription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2EventSubscription(global::V4l2.AutoGen.V4l2EventSubscription _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2EventSubscription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2EventSubscription.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2EventSubscription.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2DbgMatch : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 36)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint type;

            [FieldOffset(4)]
            internal uint addr;

            [FieldOffset(4)]
            internal fixed sbyte name[32];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN14v4l2_dbg_matchC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2DbgMatch> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2DbgMatch>();

        protected bool __ownsNativeInstance;

        internal static V4l2DbgMatch __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2DbgMatch(native.ToPointer(), skipVTables);
        }

        internal static V4l2DbgMatch __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2DbgMatch)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2DbgMatch __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2DbgMatch(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2DbgMatch(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2DbgMatch(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2DbgMatch()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2DbgMatch.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2DbgMatch(global::V4l2.AutoGen.V4l2DbgMatch _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2DbgMatch.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2DbgMatch.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2DbgMatch.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Addr
        {
            get
            {
                return ((__Internal*)__Instance)->addr;
            }

            set
            {
                ((__Internal*)__Instance)->addr = value;
            }
        }

        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->name, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->name[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class V4l2DbgRegister : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal global::V4l2.AutoGen.V4l2DbgMatch.__Internal match;
            internal uint size;
            internal ulong reg;
            internal ulong val;

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN17v4l2_dbg_registerC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2DbgRegister> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2DbgRegister>();

        protected bool __ownsNativeInstance;

        internal static V4l2DbgRegister __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2DbgRegister(native.ToPointer(), skipVTables);
        }

        internal static V4l2DbgRegister __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2DbgRegister)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2DbgRegister __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2DbgRegister(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2DbgRegister(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2DbgRegister(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2DbgRegister()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2DbgRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2DbgRegister(global::V4l2.AutoGen.V4l2DbgRegister _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2DbgRegister.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2DbgRegister.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2DbgRegister.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::V4l2.AutoGen.V4l2DbgMatch Match
        {
            get
            {
                return global::V4l2.AutoGen.V4l2DbgMatch.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->match));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->match = *(global::V4l2.AutoGen.V4l2DbgMatch.__Internal*) value.__Instance;
            }
        }

        public uint Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }

        public ulong Reg
        {
            get
            {
                return ((__Internal*)__Instance)->reg;
            }

            set
            {
                ((__Internal*)__Instance)->reg = value;
            }
        }

        public ulong Val
        {
            get
            {
                return ((__Internal*)__Instance)->val;
            }

            set
            {
                ((__Internal*)__Instance)->val = value;
            }
        }
    }

    public unsafe partial class V4l2DbgChipInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 200)]
        public partial struct __Internal
        {
            internal global::V4l2.AutoGen.V4l2DbgMatch.__Internal match;
            internal fixed sbyte name[32];
            internal uint flags;
            internal fixed uint reserved[32];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN18v4l2_dbg_chip_infoC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2DbgChipInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2DbgChipInfo>();

        protected bool __ownsNativeInstance;

        internal static V4l2DbgChipInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2DbgChipInfo(native.ToPointer(), skipVTables);
        }

        internal static V4l2DbgChipInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2DbgChipInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2DbgChipInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2DbgChipInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2DbgChipInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2DbgChipInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2DbgChipInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2DbgChipInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2DbgChipInfo(global::V4l2.AutoGen.V4l2DbgChipInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2DbgChipInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2DbgChipInfo.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2DbgChipInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::V4l2.AutoGen.V4l2DbgMatch Match
        {
            get
            {
                return global::V4l2.AutoGen.V4l2DbgMatch.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->match));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->match = *(global::V4l2.AutoGen.V4l2DbgMatch.__Internal*) value.__Instance;
            }
        }

        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->name, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->name[i] = value[i];
                }
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }

    /// <summary>
    /// <para>struct v4l2_create_buffers - VIDIOC_CREATE_BUFS argument</para>
    /// <para>on return, index of the first created buffer</para>
    /// <para>entry: number of requested buffers,</para>
    /// <para>return: number of created buffers</para>
    /// <para>enum v4l2_memory; buffer memory type</para>
    /// <para>frame format, for which buffers are requested</para>
    /// <para>capabilities of this buffer type.</para>
    /// <para>additional buffer management attributes (ignored unless the</para>
    /// <para>queue has V4L2_BUF_CAP_SUPPORTS_MMAP_CACHE_HINTS capability</para>
    /// <para>and configured for MMAP streaming I/O).</para>
    /// <para>future extensions</para>
    /// </summary>
    public unsafe partial class V4l2CreateBuffers : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 256)]
        public partial struct __Internal
        {
            internal uint index;
            internal uint count;
            internal uint memory;
            internal global::V4l2.AutoGen.V4l2Format.__Internal format;
            internal uint capabilities;
            internal uint flags;
            internal fixed uint reserved[6];

            [SuppressUnmanagedCodeSecurity, DllImport("v4l2", EntryPoint = "_ZN19v4l2_create_buffersC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2CreateBuffers> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::V4l2.AutoGen.V4l2CreateBuffers>();

        protected bool __ownsNativeInstance;

        internal static V4l2CreateBuffers __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new V4l2CreateBuffers(native.ToPointer(), skipVTables);
        }

        internal static V4l2CreateBuffers __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (V4l2CreateBuffers)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static V4l2CreateBuffers __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new V4l2CreateBuffers(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private V4l2CreateBuffers(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected V4l2CreateBuffers(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public V4l2CreateBuffers()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2CreateBuffers.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public V4l2CreateBuffers(global::V4l2.AutoGen.V4l2CreateBuffers _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::V4l2.AutoGen.V4l2CreateBuffers.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::V4l2.AutoGen.V4l2CreateBuffers.__Internal*) __Instance) = *((global::V4l2.AutoGen.V4l2CreateBuffers.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public uint Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        public uint Memory
        {
            get
            {
                return ((__Internal*)__Instance)->memory;
            }

            set
            {
                ((__Internal*)__Instance)->memory = value;
            }
        }

        public global::V4l2.AutoGen.V4l2Format Format
        {
            get
            {
                return global::V4l2.AutoGen.V4l2Format.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->format));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->format = *(global::V4l2.AutoGen.V4l2Format.__Internal*) value.__Instance;
            }
        }

        public uint Capabilities
        {
            get
            {
                return ((__Internal*)__Instance)->capabilities;
            }

            set
            {
                ((__Internal*)__Instance)->capabilities = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public uint[] Reserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->reserved, 6);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 6; i++)
                        ((__Internal*)__Instance)->reserved[i] = value[i];
                }
            }
        }
    }
}
